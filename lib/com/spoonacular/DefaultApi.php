<?php
/**
 * DefaultApi
 * PHP version 5
 *
 * @category Class
 * @package  com.spoonacular.client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * spoonacular API
 *
 * The spoonacular Nutrition, Recipe, and Food API allows you to access over 380,000 recipes, thousands of ingredients, 80,000 food products, and 100,000 menu items. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: david@spoonacular.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace com.spoonacular.client\com.spoonacular;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use com.spoonacular.client\ApiException;
use com.spoonacular.client\Configuration;
use com.spoonacular.client\HeaderSelector;
use com.spoonacular.client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  com.spoonacular.client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addToMealPlan
     *
     * Add to Meal Plan
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject11 $inline_object11 inline_object11 (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function addToMealPlan($username, $hash, $inline_object11)
    {
        list($response) = $this->addToMealPlanWithHttpInfo($username, $hash, $inline_object11);
        return $response;
    }

    /**
     * Operation addToMealPlanWithHttpInfo
     *
     * Add to Meal Plan
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject11 $inline_object11 (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function addToMealPlanWithHttpInfo($username, $hash, $inline_object11)
    {
        $request = $this->addToMealPlanRequest($username, $hash, $inline_object11);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addToMealPlanAsync
     *
     * Add to Meal Plan
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject11 $inline_object11 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addToMealPlanAsync($username, $hash, $inline_object11)
    {
        return $this->addToMealPlanAsyncWithHttpInfo($username, $hash, $inline_object11)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addToMealPlanAsyncWithHttpInfo
     *
     * Add to Meal Plan
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject11 $inline_object11 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addToMealPlanAsyncWithHttpInfo($username, $hash, $inline_object11)
    {
        $returnType = 'object';
        $request = $this->addToMealPlanRequest($username, $hash, $inline_object11);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addToMealPlan'
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject11 $inline_object11 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addToMealPlanRequest($username, $hash, $inline_object11)
    {
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling addToMealPlan'
            );
        }
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling addToMealPlan'
            );
        }
        // verify the required parameter 'inline_object11' is set
        if ($inline_object11 === null || (is_array($inline_object11) && count($inline_object11) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inline_object11 when calling addToMealPlan'
            );
        }

        $resourcePath = '/mealplanner/{username}/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($hash !== null) {
            $queryParams['hash'] = ObjectSerializer::toQueryValue($hash);
        }

        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($inline_object11)) {
            $_tempBody = $inline_object11;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addToShoppingList
     *
     * Add to Shopping List
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject14 $inline_object14 inline_object14 (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function addToShoppingList($username, $hash, $inline_object14)
    {
        list($response) = $this->addToShoppingListWithHttpInfo($username, $hash, $inline_object14);
        return $response;
    }

    /**
     * Operation addToShoppingListWithHttpInfo
     *
     * Add to Shopping List
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject14 $inline_object14 (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function addToShoppingListWithHttpInfo($username, $hash, $inline_object14)
    {
        $request = $this->addToShoppingListRequest($username, $hash, $inline_object14);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addToShoppingListAsync
     *
     * Add to Shopping List
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject14 $inline_object14 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addToShoppingListAsync($username, $hash, $inline_object14)
    {
        return $this->addToShoppingListAsyncWithHttpInfo($username, $hash, $inline_object14)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addToShoppingListAsyncWithHttpInfo
     *
     * Add to Shopping List
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject14 $inline_object14 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addToShoppingListAsyncWithHttpInfo($username, $hash, $inline_object14)
    {
        $returnType = 'object';
        $request = $this->addToShoppingListRequest($username, $hash, $inline_object14);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addToShoppingList'
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject14 $inline_object14 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addToShoppingListRequest($username, $hash, $inline_object14)
    {
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling addToShoppingList'
            );
        }
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling addToShoppingList'
            );
        }
        // verify the required parameter 'inline_object14' is set
        if ($inline_object14 === null || (is_array($inline_object14) && count($inline_object14) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inline_object14 when calling addToShoppingList'
            );
        }

        $resourcePath = '/mealplanner/{username}/shopping-list/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($hash !== null) {
            $queryParams['hash'] = ObjectSerializer::toQueryValue($hash);
        }

        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($inline_object14)) {
            $_tempBody = $inline_object14;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation analyzeARecipeSearchQuery
     *
     * Analyze a Recipe Search Query
     *
     * @param  string $q The recipe search query. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function analyzeARecipeSearchQuery($q)
    {
        list($response) = $this->analyzeARecipeSearchQueryWithHttpInfo($q);
        return $response;
    }

    /**
     * Operation analyzeARecipeSearchQueryWithHttpInfo
     *
     * Analyze a Recipe Search Query
     *
     * @param  string $q The recipe search query. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function analyzeARecipeSearchQueryWithHttpInfo($q)
    {
        $request = $this->analyzeARecipeSearchQueryRequest($q);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation analyzeARecipeSearchQueryAsync
     *
     * Analyze a Recipe Search Query
     *
     * @param  string $q The recipe search query. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeARecipeSearchQueryAsync($q)
    {
        return $this->analyzeARecipeSearchQueryAsyncWithHttpInfo($q)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation analyzeARecipeSearchQueryAsyncWithHttpInfo
     *
     * Analyze a Recipe Search Query
     *
     * @param  string $q The recipe search query. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeARecipeSearchQueryAsyncWithHttpInfo($q)
    {
        $returnType = 'object';
        $request = $this->analyzeARecipeSearchQueryRequest($q);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'analyzeARecipeSearchQuery'
     *
     * @param  string $q The recipe search query. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function analyzeARecipeSearchQueryRequest($q)
    {
        // verify the required parameter 'q' is set
        if ($q === null || (is_array($q) && count($q) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $q when calling analyzeARecipeSearchQuery'
            );
        }

        $resourcePath = '/recipes/queries/analyze';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($q !== null) {
            $queryParams['q'] = ObjectSerializer::toQueryValue($q);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation analyzeRecipeInstructions
     *
     * Analyze Recipe Instructions
     *
     * @param  string $instructions The instructions to be analyzed. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function analyzeRecipeInstructions($instructions)
    {
        list($response) = $this->analyzeRecipeInstructionsWithHttpInfo($instructions);
        return $response;
    }

    /**
     * Operation analyzeRecipeInstructionsWithHttpInfo
     *
     * Analyze Recipe Instructions
     *
     * @param  string $instructions The instructions to be analyzed. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function analyzeRecipeInstructionsWithHttpInfo($instructions)
    {
        $request = $this->analyzeRecipeInstructionsRequest($instructions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation analyzeRecipeInstructionsAsync
     *
     * Analyze Recipe Instructions
     *
     * @param  string $instructions The instructions to be analyzed. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeRecipeInstructionsAsync($instructions)
    {
        return $this->analyzeRecipeInstructionsAsyncWithHttpInfo($instructions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation analyzeRecipeInstructionsAsyncWithHttpInfo
     *
     * Analyze Recipe Instructions
     *
     * @param  string $instructions The instructions to be analyzed. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeRecipeInstructionsAsyncWithHttpInfo($instructions)
    {
        $returnType = 'object';
        $request = $this->analyzeRecipeInstructionsRequest($instructions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'analyzeRecipeInstructions'
     *
     * @param  string $instructions The instructions to be analyzed. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function analyzeRecipeInstructionsRequest($instructions)
    {
        // verify the required parameter 'instructions' is set
        if ($instructions === null || (is_array($instructions) && count($instructions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instructions when calling analyzeRecipeInstructions'
            );
        }

        $resourcePath = '/recipes/analyzeInstructions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($instructions !== null) {
            $formParams['instructions'] = ObjectSerializer::toFormValue($instructions);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation autocompleteIngredientSearch
     *
     * Autocomplete Ingredient Search
     *
     * @param  string $query The partial or full ingredient name. (required)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function autocompleteIngredientSearch($query, $number = null, $meta_information = null, $intolerances = null)
    {
        list($response) = $this->autocompleteIngredientSearchWithHttpInfo($query, $number, $meta_information, $intolerances);
        return $response;
    }

    /**
     * Operation autocompleteIngredientSearchWithHttpInfo
     *
     * Autocomplete Ingredient Search
     *
     * @param  string $query The partial or full ingredient name. (required)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function autocompleteIngredientSearchWithHttpInfo($query, $number = null, $meta_information = null, $intolerances = null)
    {
        $request = $this->autocompleteIngredientSearchRequest($query, $number, $meta_information, $intolerances);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation autocompleteIngredientSearchAsync
     *
     * Autocomplete Ingredient Search
     *
     * @param  string $query The partial or full ingredient name. (required)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteIngredientSearchAsync($query, $number = null, $meta_information = null, $intolerances = null)
    {
        return $this->autocompleteIngredientSearchAsyncWithHttpInfo($query, $number, $meta_information, $intolerances)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation autocompleteIngredientSearchAsyncWithHttpInfo
     *
     * Autocomplete Ingredient Search
     *
     * @param  string $query The partial or full ingredient name. (required)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteIngredientSearchAsyncWithHttpInfo($query, $number = null, $meta_information = null, $intolerances = null)
    {
        $returnType = 'object';
        $request = $this->autocompleteIngredientSearchRequest($query, $number, $meta_information, $intolerances);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'autocompleteIngredientSearch'
     *
     * @param  string $query The partial or full ingredient name. (required)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function autocompleteIngredientSearchRequest($query, $number = null, $meta_information = null, $intolerances = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling autocompleteIngredientSearch'
            );
        }

        $resourcePath = '/food/ingredients/autocomplete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }
        // query params
        if ($meta_information !== null) {
            $queryParams['metaInformation'] = ObjectSerializer::toQueryValue($meta_information);
        }
        // query params
        if ($intolerances !== null) {
            $queryParams['intolerances'] = ObjectSerializer::toQueryValue($intolerances);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation autocompleteMenuItemSearch
     *
     * Autocomplete Menu Item Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function autocompleteMenuItemSearch($query, $number = null)
    {
        list($response) = $this->autocompleteMenuItemSearchWithHttpInfo($query, $number);
        return $response;
    }

    /**
     * Operation autocompleteMenuItemSearchWithHttpInfo
     *
     * Autocomplete Menu Item Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function autocompleteMenuItemSearchWithHttpInfo($query, $number = null)
    {
        $request = $this->autocompleteMenuItemSearchRequest($query, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation autocompleteMenuItemSearchAsync
     *
     * Autocomplete Menu Item Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteMenuItemSearchAsync($query, $number = null)
    {
        return $this->autocompleteMenuItemSearchAsyncWithHttpInfo($query, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation autocompleteMenuItemSearchAsyncWithHttpInfo
     *
     * Autocomplete Menu Item Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteMenuItemSearchAsyncWithHttpInfo($query, $number = null)
    {
        $returnType = 'object';
        $request = $this->autocompleteMenuItemSearchRequest($query, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'autocompleteMenuItemSearch'
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function autocompleteMenuItemSearchRequest($query, $number = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling autocompleteMenuItemSearch'
            );
        }

        $resourcePath = '/food/menuItems/suggest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation autocompleteProductSearch
     *
     * Autocomplete Product Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function autocompleteProductSearch($query, $number = null)
    {
        list($response) = $this->autocompleteProductSearchWithHttpInfo($query, $number);
        return $response;
    }

    /**
     * Operation autocompleteProductSearchWithHttpInfo
     *
     * Autocomplete Product Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function autocompleteProductSearchWithHttpInfo($query, $number = null)
    {
        $request = $this->autocompleteProductSearchRequest($query, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation autocompleteProductSearchAsync
     *
     * Autocomplete Product Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteProductSearchAsync($query, $number = null)
    {
        return $this->autocompleteProductSearchAsyncWithHttpInfo($query, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation autocompleteProductSearchAsyncWithHttpInfo
     *
     * Autocomplete Product Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteProductSearchAsyncWithHttpInfo($query, $number = null)
    {
        $returnType = 'object';
        $request = $this->autocompleteProductSearchRequest($query, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'autocompleteProductSearch'
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function autocompleteProductSearchRequest($query, $number = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling autocompleteProductSearch'
            );
        }

        $resourcePath = '/food/products/suggest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation autocompleteRecipeSearch
     *
     * Autocomplete Recipe Search
     *
     * @param  string $query The query to be autocompleted. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function autocompleteRecipeSearch($query, $number = null)
    {
        list($response) = $this->autocompleteRecipeSearchWithHttpInfo($query, $number);
        return $response;
    }

    /**
     * Operation autocompleteRecipeSearchWithHttpInfo
     *
     * Autocomplete Recipe Search
     *
     * @param  string $query The query to be autocompleted. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function autocompleteRecipeSearchWithHttpInfo($query, $number = null)
    {
        $request = $this->autocompleteRecipeSearchRequest($query, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation autocompleteRecipeSearchAsync
     *
     * Autocomplete Recipe Search
     *
     * @param  string $query The query to be autocompleted. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteRecipeSearchAsync($query, $number = null)
    {
        return $this->autocompleteRecipeSearchAsyncWithHttpInfo($query, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation autocompleteRecipeSearchAsyncWithHttpInfo
     *
     * Autocomplete Recipe Search
     *
     * @param  string $query The query to be autocompleted. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteRecipeSearchAsyncWithHttpInfo($query, $number = null)
    {
        $returnType = 'object';
        $request = $this->autocompleteRecipeSearchRequest($query, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'autocompleteRecipeSearch'
     *
     * @param  string $query The query to be autocompleted. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function autocompleteRecipeSearchRequest($query, $number = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling autocompleteRecipeSearch'
            );
        }

        $resourcePath = '/recipes/autocomplete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation classifyCuisine
     *
     * Classify Cuisine
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function classifyCuisine($title, $ingredient_list)
    {
        list($response) = $this->classifyCuisineWithHttpInfo($title, $ingredient_list);
        return $response;
    }

    /**
     * Operation classifyCuisineWithHttpInfo
     *
     * Classify Cuisine
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function classifyCuisineWithHttpInfo($title, $ingredient_list)
    {
        $request = $this->classifyCuisineRequest($title, $ingredient_list);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation classifyCuisineAsync
     *
     * Classify Cuisine
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyCuisineAsync($title, $ingredient_list)
    {
        return $this->classifyCuisineAsyncWithHttpInfo($title, $ingredient_list)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation classifyCuisineAsyncWithHttpInfo
     *
     * Classify Cuisine
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyCuisineAsyncWithHttpInfo($title, $ingredient_list)
    {
        $returnType = 'object';
        $request = $this->classifyCuisineRequest($title, $ingredient_list);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'classifyCuisine'
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function classifyCuisineRequest($title, $ingredient_list)
    {
        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling classifyCuisine'
            );
        }
        // verify the required parameter 'ingredient_list' is set
        if ($ingredient_list === null || (is_array($ingredient_list) && count($ingredient_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_list when calling classifyCuisine'
            );
        }

        $resourcePath = '/recipes/cuisine';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($title !== null) {
            $formParams['title'] = ObjectSerializer::toFormValue($title);
        }
        // form params
        if ($ingredient_list !== null) {
            $formParams['ingredientList'] = ObjectSerializer::toFormValue($ingredient_list);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation classifyGroceryProduct
     *
     * Classify Grocery Product
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject9 $inline_object9 inline_object9 (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function classifyGroceryProduct($inline_object9, $locale = null)
    {
        list($response) = $this->classifyGroceryProductWithHttpInfo($inline_object9, $locale);
        return $response;
    }

    /**
     * Operation classifyGroceryProductWithHttpInfo
     *
     * Classify Grocery Product
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject9 $inline_object9 (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function classifyGroceryProductWithHttpInfo($inline_object9, $locale = null)
    {
        $request = $this->classifyGroceryProductRequest($inline_object9, $locale);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation classifyGroceryProductAsync
     *
     * Classify Grocery Product
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject9 $inline_object9 (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyGroceryProductAsync($inline_object9, $locale = null)
    {
        return $this->classifyGroceryProductAsyncWithHttpInfo($inline_object9, $locale)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation classifyGroceryProductAsyncWithHttpInfo
     *
     * Classify Grocery Product
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject9 $inline_object9 (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyGroceryProductAsyncWithHttpInfo($inline_object9, $locale = null)
    {
        $returnType = 'object';
        $request = $this->classifyGroceryProductRequest($inline_object9, $locale);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'classifyGroceryProduct'
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject9 $inline_object9 (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function classifyGroceryProductRequest($inline_object9, $locale = null)
    {
        // verify the required parameter 'inline_object9' is set
        if ($inline_object9 === null || (is_array($inline_object9) && count($inline_object9) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inline_object9 when calling classifyGroceryProduct'
            );
        }

        $resourcePath = '/food/products/classify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($locale !== null) {
            $queryParams['locale'] = ObjectSerializer::toQueryValue($locale);
        }


        // body params
        $_tempBody = null;
        if (isset($inline_object9)) {
            $_tempBody = $inline_object9;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation classifyGroceryProductBulk
     *
     * Classify Grocery Product Bulk
     *
     * @param  object $body body (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function classifyGroceryProductBulk($body, $locale = null)
    {
        list($response) = $this->classifyGroceryProductBulkWithHttpInfo($body, $locale);
        return $response;
    }

    /**
     * Operation classifyGroceryProductBulkWithHttpInfo
     *
     * Classify Grocery Product Bulk
     *
     * @param  object $body (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function classifyGroceryProductBulkWithHttpInfo($body, $locale = null)
    {
        $request = $this->classifyGroceryProductBulkRequest($body, $locale);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation classifyGroceryProductBulkAsync
     *
     * Classify Grocery Product Bulk
     *
     * @param  object $body (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyGroceryProductBulkAsync($body, $locale = null)
    {
        return $this->classifyGroceryProductBulkAsyncWithHttpInfo($body, $locale)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation classifyGroceryProductBulkAsyncWithHttpInfo
     *
     * Classify Grocery Product Bulk
     *
     * @param  object $body (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyGroceryProductBulkAsyncWithHttpInfo($body, $locale = null)
    {
        $returnType = 'object';
        $request = $this->classifyGroceryProductBulkRequest($body, $locale);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'classifyGroceryProductBulk'
     *
     * @param  object $body (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function classifyGroceryProductBulkRequest($body, $locale = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling classifyGroceryProductBulk'
            );
        }

        $resourcePath = '/food/products/classifyBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($locale !== null) {
            $queryParams['locale'] = ObjectSerializer::toQueryValue($locale);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clearMealPlanDay
     *
     * Clear Meal Plan Day
     *
     * @param  string $username The username. (required)
     * @param  string $date The date in the format yyyy-mm-dd. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject10 $inline_object10 inline_object10 (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function clearMealPlanDay($username, $date, $hash, $inline_object10)
    {
        list($response) = $this->clearMealPlanDayWithHttpInfo($username, $date, $hash, $inline_object10);
        return $response;
    }

    /**
     * Operation clearMealPlanDayWithHttpInfo
     *
     * Clear Meal Plan Day
     *
     * @param  string $username The username. (required)
     * @param  string $date The date in the format yyyy-mm-dd. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject10 $inline_object10 (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function clearMealPlanDayWithHttpInfo($username, $date, $hash, $inline_object10)
    {
        $request = $this->clearMealPlanDayRequest($username, $date, $hash, $inline_object10);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clearMealPlanDayAsync
     *
     * Clear Meal Plan Day
     *
     * @param  string $username The username. (required)
     * @param  string $date The date in the format yyyy-mm-dd. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject10 $inline_object10 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clearMealPlanDayAsync($username, $date, $hash, $inline_object10)
    {
        return $this->clearMealPlanDayAsyncWithHttpInfo($username, $date, $hash, $inline_object10)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clearMealPlanDayAsyncWithHttpInfo
     *
     * Clear Meal Plan Day
     *
     * @param  string $username The username. (required)
     * @param  string $date The date in the format yyyy-mm-dd. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject10 $inline_object10 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clearMealPlanDayAsyncWithHttpInfo($username, $date, $hash, $inline_object10)
    {
        $returnType = 'object';
        $request = $this->clearMealPlanDayRequest($username, $date, $hash, $inline_object10);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clearMealPlanDay'
     *
     * @param  string $username The username. (required)
     * @param  string $date The date in the format yyyy-mm-dd. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject10 $inline_object10 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clearMealPlanDayRequest($username, $date, $hash, $inline_object10)
    {
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling clearMealPlanDay'
            );
        }
        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling clearMealPlanDay'
            );
        }
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling clearMealPlanDay'
            );
        }
        // verify the required parameter 'inline_object10' is set
        if ($inline_object10 === null || (is_array($inline_object10) && count($inline_object10) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inline_object10 when calling clearMealPlanDay'
            );
        }

        $resourcePath = '/mealplanner/{username}/day/{date}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($hash !== null) {
            $queryParams['hash'] = ObjectSerializer::toQueryValue($hash);
        }

        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }
        // path params
        if ($date !== null) {
            $resourcePath = str_replace(
                '{' . 'date' . '}',
                ObjectSerializer::toPathValue($date),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($inline_object10)) {
            $_tempBody = $inline_object10;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation computeGlycemicLoad
     *
     * Compute Glycemic Load
     *
     * @param  object $body body (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function computeGlycemicLoad($body)
    {
        list($response) = $this->computeGlycemicLoadWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation computeGlycemicLoadWithHttpInfo
     *
     * Compute Glycemic Load
     *
     * @param  object $body (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function computeGlycemicLoadWithHttpInfo($body)
    {
        $request = $this->computeGlycemicLoadRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation computeGlycemicLoadAsync
     *
     * Compute Glycemic Load
     *
     * @param  object $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function computeGlycemicLoadAsync($body)
    {
        return $this->computeGlycemicLoadAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation computeGlycemicLoadAsyncWithHttpInfo
     *
     * Compute Glycemic Load
     *
     * @param  object $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function computeGlycemicLoadAsyncWithHttpInfo($body)
    {
        $returnType = 'object';
        $request = $this->computeGlycemicLoadRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'computeGlycemicLoad'
     *
     * @param  object $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function computeGlycemicLoadRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling computeGlycemicLoad'
            );
        }

        $resourcePath = '/food/ingredients/glycemicLoad';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation connectUser
     *
     * Connect User
     *
     * @param  object $body body (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function connectUser($body)
    {
        list($response) = $this->connectUserWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation connectUserWithHttpInfo
     *
     * Connect User
     *
     * @param  object $body (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function connectUserWithHttpInfo($body)
    {
        $request = $this->connectUserRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation connectUserAsync
     *
     * Connect User
     *
     * @param  object $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function connectUserAsync($body)
    {
        return $this->connectUserAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation connectUserAsyncWithHttpInfo
     *
     * Connect User
     *
     * @param  object $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function connectUserAsyncWithHttpInfo($body)
    {
        $returnType = 'object';
        $request = $this->connectUserRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'connectUser'
     *
     * @param  object $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function connectUserRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling connectUser'
            );
        }

        $resourcePath = '/users/connect';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation convertAmounts
     *
     * Convert Amounts
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function convertAmounts($ingredient_name, $source_amount, $source_unit, $target_unit)
    {
        list($response) = $this->convertAmountsWithHttpInfo($ingredient_name, $source_amount, $source_unit, $target_unit);
        return $response;
    }

    /**
     * Operation convertAmountsWithHttpInfo
     *
     * Convert Amounts
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function convertAmountsWithHttpInfo($ingredient_name, $source_amount, $source_unit, $target_unit)
    {
        $request = $this->convertAmountsRequest($ingredient_name, $source_amount, $source_unit, $target_unit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation convertAmountsAsync
     *
     * Convert Amounts
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function convertAmountsAsync($ingredient_name, $source_amount, $source_unit, $target_unit)
    {
        return $this->convertAmountsAsyncWithHttpInfo($ingredient_name, $source_amount, $source_unit, $target_unit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation convertAmountsAsyncWithHttpInfo
     *
     * Convert Amounts
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function convertAmountsAsyncWithHttpInfo($ingredient_name, $source_amount, $source_unit, $target_unit)
    {
        $returnType = 'object';
        $request = $this->convertAmountsRequest($ingredient_name, $source_amount, $source_unit, $target_unit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'convertAmounts'
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function convertAmountsRequest($ingredient_name, $source_amount, $source_unit, $target_unit)
    {
        // verify the required parameter 'ingredient_name' is set
        if ($ingredient_name === null || (is_array($ingredient_name) && count($ingredient_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_name when calling convertAmounts'
            );
        }
        // verify the required parameter 'source_amount' is set
        if ($source_amount === null || (is_array($source_amount) && count($source_amount) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source_amount when calling convertAmounts'
            );
        }
        // verify the required parameter 'source_unit' is set
        if ($source_unit === null || (is_array($source_unit) && count($source_unit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source_unit when calling convertAmounts'
            );
        }
        // verify the required parameter 'target_unit' is set
        if ($target_unit === null || (is_array($target_unit) && count($target_unit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $target_unit when calling convertAmounts'
            );
        }

        $resourcePath = '/recipes/convert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ingredient_name !== null) {
            $queryParams['ingredientName'] = ObjectSerializer::toQueryValue($ingredient_name);
        }
        // query params
        if ($source_amount !== null) {
            $queryParams['sourceAmount'] = ObjectSerializer::toQueryValue($source_amount);
        }
        // query params
        if ($source_unit !== null) {
            $queryParams['sourceUnit'] = ObjectSerializer::toQueryValue($source_unit);
        }
        // query params
        if ($target_unit !== null) {
            $queryParams['targetUnit'] = ObjectSerializer::toQueryValue($target_unit);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRecipeCard
     *
     * Create Recipe Card
     *
     * @param  string $title The title of the recipe. (required)
     * @param  \SplFileObject $image The binary image of the recipe as jpg. (required)
     * @param  string $ingredients The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $instructions The instructions to make the recipe. One step per line (separate lines with \\\\n). (required)
     * @param  float $ready_in_minutes The number of minutes it takes to get the recipe on the table. (required)
     * @param  float $servings The number of servings the recipe makes. (required)
     * @param  string $mask The mask to put over the recipe image (\\\&quot;ellipseMask\\\&quot;, \\\&quot;diamondMask\\\&quot;, \\\&quot;starMask\\\&quot;, \\\&quot;heartMask\\\&quot;, \\\&quot;potMask\\\&quot;, \\\&quot;fishMask\\\&quot;). (required)
     * @param  string $background_image The background image (\\\&quot;none\\\&quot;,\\\&quot;background1\\\&quot;, or \\\&quot;background2\\\&quot;). (required)
     * @param  string $author The author of the recipe. (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     * @param  string $source The source of the recipe. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function createRecipeCard($title, $image, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $author = null, $background_color = null, $font_color = null, $source = null)
    {
        list($response) = $this->createRecipeCardWithHttpInfo($title, $image, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $author, $background_color, $font_color, $source);
        return $response;
    }

    /**
     * Operation createRecipeCardWithHttpInfo
     *
     * Create Recipe Card
     *
     * @param  string $title The title of the recipe. (required)
     * @param  \SplFileObject $image The binary image of the recipe as jpg. (required)
     * @param  string $ingredients The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $instructions The instructions to make the recipe. One step per line (separate lines with \\\\n). (required)
     * @param  float $ready_in_minutes The number of minutes it takes to get the recipe on the table. (required)
     * @param  float $servings The number of servings the recipe makes. (required)
     * @param  string $mask The mask to put over the recipe image (\\\&quot;ellipseMask\\\&quot;, \\\&quot;diamondMask\\\&quot;, \\\&quot;starMask\\\&quot;, \\\&quot;heartMask\\\&quot;, \\\&quot;potMask\\\&quot;, \\\&quot;fishMask\\\&quot;). (required)
     * @param  string $background_image The background image (\\\&quot;none\\\&quot;,\\\&quot;background1\\\&quot;, or \\\&quot;background2\\\&quot;). (required)
     * @param  string $author The author of the recipe. (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     * @param  string $source The source of the recipe. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRecipeCardWithHttpInfo($title, $image, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $author = null, $background_color = null, $font_color = null, $source = null)
    {
        $request = $this->createRecipeCardRequest($title, $image, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $author, $background_color, $font_color, $source);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRecipeCardAsync
     *
     * Create Recipe Card
     *
     * @param  string $title The title of the recipe. (required)
     * @param  \SplFileObject $image The binary image of the recipe as jpg. (required)
     * @param  string $ingredients The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $instructions The instructions to make the recipe. One step per line (separate lines with \\\\n). (required)
     * @param  float $ready_in_minutes The number of minutes it takes to get the recipe on the table. (required)
     * @param  float $servings The number of servings the recipe makes. (required)
     * @param  string $mask The mask to put over the recipe image (\\\&quot;ellipseMask\\\&quot;, \\\&quot;diamondMask\\\&quot;, \\\&quot;starMask\\\&quot;, \\\&quot;heartMask\\\&quot;, \\\&quot;potMask\\\&quot;, \\\&quot;fishMask\\\&quot;). (required)
     * @param  string $background_image The background image (\\\&quot;none\\\&quot;,\\\&quot;background1\\\&quot;, or \\\&quot;background2\\\&quot;). (required)
     * @param  string $author The author of the recipe. (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     * @param  string $source The source of the recipe. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRecipeCardAsync($title, $image, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $author = null, $background_color = null, $font_color = null, $source = null)
    {
        return $this->createRecipeCardAsyncWithHttpInfo($title, $image, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $author, $background_color, $font_color, $source)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRecipeCardAsyncWithHttpInfo
     *
     * Create Recipe Card
     *
     * @param  string $title The title of the recipe. (required)
     * @param  \SplFileObject $image The binary image of the recipe as jpg. (required)
     * @param  string $ingredients The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $instructions The instructions to make the recipe. One step per line (separate lines with \\\\n). (required)
     * @param  float $ready_in_minutes The number of minutes it takes to get the recipe on the table. (required)
     * @param  float $servings The number of servings the recipe makes. (required)
     * @param  string $mask The mask to put over the recipe image (\\\&quot;ellipseMask\\\&quot;, \\\&quot;diamondMask\\\&quot;, \\\&quot;starMask\\\&quot;, \\\&quot;heartMask\\\&quot;, \\\&quot;potMask\\\&quot;, \\\&quot;fishMask\\\&quot;). (required)
     * @param  string $background_image The background image (\\\&quot;none\\\&quot;,\\\&quot;background1\\\&quot;, or \\\&quot;background2\\\&quot;). (required)
     * @param  string $author The author of the recipe. (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     * @param  string $source The source of the recipe. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRecipeCardAsyncWithHttpInfo($title, $image, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $author = null, $background_color = null, $font_color = null, $source = null)
    {
        $returnType = 'object';
        $request = $this->createRecipeCardRequest($title, $image, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $author, $background_color, $font_color, $source);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRecipeCard'
     *
     * @param  string $title The title of the recipe. (required)
     * @param  \SplFileObject $image The binary image of the recipe as jpg. (required)
     * @param  string $ingredients The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $instructions The instructions to make the recipe. One step per line (separate lines with \\\\n). (required)
     * @param  float $ready_in_minutes The number of minutes it takes to get the recipe on the table. (required)
     * @param  float $servings The number of servings the recipe makes. (required)
     * @param  string $mask The mask to put over the recipe image (\\\&quot;ellipseMask\\\&quot;, \\\&quot;diamondMask\\\&quot;, \\\&quot;starMask\\\&quot;, \\\&quot;heartMask\\\&quot;, \\\&quot;potMask\\\&quot;, \\\&quot;fishMask\\\&quot;). (required)
     * @param  string $background_image The background image (\\\&quot;none\\\&quot;,\\\&quot;background1\\\&quot;, or \\\&quot;background2\\\&quot;). (required)
     * @param  string $author The author of the recipe. (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     * @param  string $source The source of the recipe. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createRecipeCardRequest($title, $image, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $author = null, $background_color = null, $font_color = null, $source = null)
    {
        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling createRecipeCard'
            );
        }
        // verify the required parameter 'image' is set
        if ($image === null || (is_array($image) && count($image) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image when calling createRecipeCard'
            );
        }
        // verify the required parameter 'ingredients' is set
        if ($ingredients === null || (is_array($ingredients) && count($ingredients) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredients when calling createRecipeCard'
            );
        }
        // verify the required parameter 'instructions' is set
        if ($instructions === null || (is_array($instructions) && count($instructions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instructions when calling createRecipeCard'
            );
        }
        // verify the required parameter 'ready_in_minutes' is set
        if ($ready_in_minutes === null || (is_array($ready_in_minutes) && count($ready_in_minutes) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ready_in_minutes when calling createRecipeCard'
            );
        }
        // verify the required parameter 'servings' is set
        if ($servings === null || (is_array($servings) && count($servings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $servings when calling createRecipeCard'
            );
        }
        // verify the required parameter 'mask' is set
        if ($mask === null || (is_array($mask) && count($mask) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mask when calling createRecipeCard'
            );
        }
        // verify the required parameter 'background_image' is set
        if ($background_image === null || (is_array($background_image) && count($background_image) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $background_image when calling createRecipeCard'
            );
        }

        $resourcePath = '/recipes/visualizeRecipe';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($title !== null) {
            $formParams['title'] = ObjectSerializer::toFormValue($title);
        }
        // form params
        if ($image !== null) {
            $multipart = true;
            $formParams['image'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($image), 'rb');
        }
        // form params
        if ($ingredients !== null) {
            $formParams['ingredients'] = ObjectSerializer::toFormValue($ingredients);
        }
        // form params
        if ($instructions !== null) {
            $formParams['instructions'] = ObjectSerializer::toFormValue($instructions);
        }
        // form params
        if ($ready_in_minutes !== null) {
            $formParams['readyInMinutes'] = ObjectSerializer::toFormValue($ready_in_minutes);
        }
        // form params
        if ($servings !== null) {
            $formParams['servings'] = ObjectSerializer::toFormValue($servings);
        }
        // form params
        if ($mask !== null) {
            $formParams['mask'] = ObjectSerializer::toFormValue($mask);
        }
        // form params
        if ($background_image !== null) {
            $formParams['backgroundImage'] = ObjectSerializer::toFormValue($background_image);
        }
        // form params
        if ($author !== null) {
            $formParams['author'] = ObjectSerializer::toFormValue($author);
        }
        // form params
        if ($background_color !== null) {
            $formParams['backgroundColor'] = ObjectSerializer::toFormValue($background_color);
        }
        // form params
        if ($font_color !== null) {
            $formParams['fontColor'] = ObjectSerializer::toFormValue($font_color);
        }
        // form params
        if ($source !== null) {
            $formParams['source'] = ObjectSerializer::toFormValue($source);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFromMealPlan
     *
     * Delete from Meal Plan
     *
     * @param  string $username The username. (required)
     * @param  float $id The shopping list item id. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject12 $inline_object12 inline_object12 (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteFromMealPlan($username, $id, $hash, $inline_object12)
    {
        list($response) = $this->deleteFromMealPlanWithHttpInfo($username, $id, $hash, $inline_object12);
        return $response;
    }

    /**
     * Operation deleteFromMealPlanWithHttpInfo
     *
     * Delete from Meal Plan
     *
     * @param  string $username The username. (required)
     * @param  float $id The shopping list item id. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject12 $inline_object12 (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFromMealPlanWithHttpInfo($username, $id, $hash, $inline_object12)
    {
        $request = $this->deleteFromMealPlanRequest($username, $id, $hash, $inline_object12);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFromMealPlanAsync
     *
     * Delete from Meal Plan
     *
     * @param  string $username The username. (required)
     * @param  float $id The shopping list item id. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject12 $inline_object12 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFromMealPlanAsync($username, $id, $hash, $inline_object12)
    {
        return $this->deleteFromMealPlanAsyncWithHttpInfo($username, $id, $hash, $inline_object12)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFromMealPlanAsyncWithHttpInfo
     *
     * Delete from Meal Plan
     *
     * @param  string $username The username. (required)
     * @param  float $id The shopping list item id. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject12 $inline_object12 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFromMealPlanAsyncWithHttpInfo($username, $id, $hash, $inline_object12)
    {
        $returnType = 'object';
        $request = $this->deleteFromMealPlanRequest($username, $id, $hash, $inline_object12);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFromMealPlan'
     *
     * @param  string $username The username. (required)
     * @param  float $id The shopping list item id. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject12 $inline_object12 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFromMealPlanRequest($username, $id, $hash, $inline_object12)
    {
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling deleteFromMealPlan'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteFromMealPlan'
            );
        }
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling deleteFromMealPlan'
            );
        }
        // verify the required parameter 'inline_object12' is set
        if ($inline_object12 === null || (is_array($inline_object12) && count($inline_object12) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inline_object12 when calling deleteFromMealPlan'
            );
        }

        $resourcePath = '/mealplanner/{username}/items/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($hash !== null) {
            $queryParams['hash'] = ObjectSerializer::toQueryValue($hash);
        }

        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($inline_object12)) {
            $_tempBody = $inline_object12;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFromShoppingList
     *
     * Delete from Shopping List
     *
     * @param  string $username The username. (required)
     * @param  float $id The shopping list item id. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject15 $inline_object15 inline_object15 (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteFromShoppingList($username, $id, $hash, $inline_object15)
    {
        list($response) = $this->deleteFromShoppingListWithHttpInfo($username, $id, $hash, $inline_object15);
        return $response;
    }

    /**
     * Operation deleteFromShoppingListWithHttpInfo
     *
     * Delete from Shopping List
     *
     * @param  string $username The username. (required)
     * @param  float $id The shopping list item id. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject15 $inline_object15 (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFromShoppingListWithHttpInfo($username, $id, $hash, $inline_object15)
    {
        $request = $this->deleteFromShoppingListRequest($username, $id, $hash, $inline_object15);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFromShoppingListAsync
     *
     * Delete from Shopping List
     *
     * @param  string $username The username. (required)
     * @param  float $id The shopping list item id. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject15 $inline_object15 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFromShoppingListAsync($username, $id, $hash, $inline_object15)
    {
        return $this->deleteFromShoppingListAsyncWithHttpInfo($username, $id, $hash, $inline_object15)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFromShoppingListAsyncWithHttpInfo
     *
     * Delete from Shopping List
     *
     * @param  string $username The username. (required)
     * @param  float $id The shopping list item id. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject15 $inline_object15 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFromShoppingListAsyncWithHttpInfo($username, $id, $hash, $inline_object15)
    {
        $returnType = 'object';
        $request = $this->deleteFromShoppingListRequest($username, $id, $hash, $inline_object15);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFromShoppingList'
     *
     * @param  string $username The username. (required)
     * @param  float $id The shopping list item id. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject15 $inline_object15 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFromShoppingListRequest($username, $id, $hash, $inline_object15)
    {
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling deleteFromShoppingList'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteFromShoppingList'
            );
        }
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling deleteFromShoppingList'
            );
        }
        // verify the required parameter 'inline_object15' is set
        if ($inline_object15 === null || (is_array($inline_object15) && count($inline_object15) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inline_object15 when calling deleteFromShoppingList'
            );
        }

        $resourcePath = '/mealplanner/{username}/shopping-list/items/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($hash !== null) {
            $queryParams['hash'] = ObjectSerializer::toQueryValue($hash);
        }

        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($inline_object15)) {
            $_tempBody = $inline_object15;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation detectFoodInText
     *
     * Detect Food in Text
     *
     * @param  string $text The text in which food items, such as dish names and ingredients, should be detected in. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function detectFoodInText($text)
    {
        list($response) = $this->detectFoodInTextWithHttpInfo($text);
        return $response;
    }

    /**
     * Operation detectFoodInTextWithHttpInfo
     *
     * Detect Food in Text
     *
     * @param  string $text The text in which food items, such as dish names and ingredients, should be detected in. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function detectFoodInTextWithHttpInfo($text)
    {
        $request = $this->detectFoodInTextRequest($text);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation detectFoodInTextAsync
     *
     * Detect Food in Text
     *
     * @param  string $text The text in which food items, such as dish names and ingredients, should be detected in. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function detectFoodInTextAsync($text)
    {
        return $this->detectFoodInTextAsyncWithHttpInfo($text)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation detectFoodInTextAsyncWithHttpInfo
     *
     * Detect Food in Text
     *
     * @param  string $text The text in which food items, such as dish names and ingredients, should be detected in. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function detectFoodInTextAsyncWithHttpInfo($text)
    {
        $returnType = 'object';
        $request = $this->detectFoodInTextRequest($text);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'detectFoodInText'
     *
     * @param  string $text The text in which food items, such as dish names and ingredients, should be detected in. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function detectFoodInTextRequest($text)
    {
        // verify the required parameter 'text' is set
        if ($text === null || (is_array($text) && count($text) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text when calling detectFoodInText'
            );
        }

        $resourcePath = '/food/detect';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($text !== null) {
            $formParams['text'] = ObjectSerializer::toFormValue($text);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extractRecipeFromWebsite
     *
     * Extract Recipe from Website
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower. (optional)
     * @param  bool $analyze If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function extractRecipeFromWebsite($url, $force_extraction = null, $analyze = null)
    {
        list($response) = $this->extractRecipeFromWebsiteWithHttpInfo($url, $force_extraction, $analyze);
        return $response;
    }

    /**
     * Operation extractRecipeFromWebsiteWithHttpInfo
     *
     * Extract Recipe from Website
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower. (optional)
     * @param  bool $analyze If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function extractRecipeFromWebsiteWithHttpInfo($url, $force_extraction = null, $analyze = null)
    {
        $request = $this->extractRecipeFromWebsiteRequest($url, $force_extraction, $analyze);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extractRecipeFromWebsiteAsync
     *
     * Extract Recipe from Website
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower. (optional)
     * @param  bool $analyze If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractRecipeFromWebsiteAsync($url, $force_extraction = null, $analyze = null)
    {
        return $this->extractRecipeFromWebsiteAsyncWithHttpInfo($url, $force_extraction, $analyze)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extractRecipeFromWebsiteAsyncWithHttpInfo
     *
     * Extract Recipe from Website
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower. (optional)
     * @param  bool $analyze If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractRecipeFromWebsiteAsyncWithHttpInfo($url, $force_extraction = null, $analyze = null)
    {
        $returnType = 'object';
        $request = $this->extractRecipeFromWebsiteRequest($url, $force_extraction, $analyze);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extractRecipeFromWebsite'
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower. (optional)
     * @param  bool $analyze If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function extractRecipeFromWebsiteRequest($url, $force_extraction = null, $analyze = null)
    {
        // verify the required parameter 'url' is set
        if ($url === null || (is_array($url) && count($url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url when calling extractRecipeFromWebsite'
            );
        }

        $resourcePath = '/recipes/extract';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url);
        }
        // query params
        if ($force_extraction !== null) {
            $queryParams['forceExtraction'] = ObjectSerializer::toQueryValue($force_extraction);
        }
        // query params
        if ($analyze !== null) {
            $queryParams['analyze'] = ObjectSerializer::toQueryValue($analyze);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generateMealPlan
     *
     * Generate Meal Plan
     *
     * @param  string $time_frame Either for one \&quot;day\&quot; or an entire \&quot;week\&quot;. (optional)
     * @param  float $target_calories What is the caloric target for one day? The meal plan generator will try to get as close as possible to that goal. (optional)
     * @param  string $diet Enter a diet that the meal plan has to adhere to. See a full list of supported diets. (optional)
     * @param  string $exclude A comma-separated list of allergens or ingredients that must be excluded. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function generateMealPlan($time_frame = null, $target_calories = null, $diet = null, $exclude = null)
    {
        list($response) = $this->generateMealPlanWithHttpInfo($time_frame, $target_calories, $diet, $exclude);
        return $response;
    }

    /**
     * Operation generateMealPlanWithHttpInfo
     *
     * Generate Meal Plan
     *
     * @param  string $time_frame Either for one \&quot;day\&quot; or an entire \&quot;week\&quot;. (optional)
     * @param  float $target_calories What is the caloric target for one day? The meal plan generator will try to get as close as possible to that goal. (optional)
     * @param  string $diet Enter a diet that the meal plan has to adhere to. See a full list of supported diets. (optional)
     * @param  string $exclude A comma-separated list of allergens or ingredients that must be excluded. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function generateMealPlanWithHttpInfo($time_frame = null, $target_calories = null, $diet = null, $exclude = null)
    {
        $request = $this->generateMealPlanRequest($time_frame, $target_calories, $diet, $exclude);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation generateMealPlanAsync
     *
     * Generate Meal Plan
     *
     * @param  string $time_frame Either for one \&quot;day\&quot; or an entire \&quot;week\&quot;. (optional)
     * @param  float $target_calories What is the caloric target for one day? The meal plan generator will try to get as close as possible to that goal. (optional)
     * @param  string $diet Enter a diet that the meal plan has to adhere to. See a full list of supported diets. (optional)
     * @param  string $exclude A comma-separated list of allergens or ingredients that must be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateMealPlanAsync($time_frame = null, $target_calories = null, $diet = null, $exclude = null)
    {
        return $this->generateMealPlanAsyncWithHttpInfo($time_frame, $target_calories, $diet, $exclude)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generateMealPlanAsyncWithHttpInfo
     *
     * Generate Meal Plan
     *
     * @param  string $time_frame Either for one \&quot;day\&quot; or an entire \&quot;week\&quot;. (optional)
     * @param  float $target_calories What is the caloric target for one day? The meal plan generator will try to get as close as possible to that goal. (optional)
     * @param  string $diet Enter a diet that the meal plan has to adhere to. See a full list of supported diets. (optional)
     * @param  string $exclude A comma-separated list of allergens or ingredients that must be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateMealPlanAsyncWithHttpInfo($time_frame = null, $target_calories = null, $diet = null, $exclude = null)
    {
        $returnType = 'object';
        $request = $this->generateMealPlanRequest($time_frame, $target_calories, $diet, $exclude);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generateMealPlan'
     *
     * @param  string $time_frame Either for one \&quot;day\&quot; or an entire \&quot;week\&quot;. (optional)
     * @param  float $target_calories What is the caloric target for one day? The meal plan generator will try to get as close as possible to that goal. (optional)
     * @param  string $diet Enter a diet that the meal plan has to adhere to. See a full list of supported diets. (optional)
     * @param  string $exclude A comma-separated list of allergens or ingredients that must be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function generateMealPlanRequest($time_frame = null, $target_calories = null, $diet = null, $exclude = null)
    {

        $resourcePath = '/mealplanner/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($time_frame !== null) {
            $queryParams['timeFrame'] = ObjectSerializer::toQueryValue($time_frame);
        }
        // query params
        if ($target_calories !== null) {
            $queryParams['targetCalories'] = ObjectSerializer::toQueryValue($target_calories);
        }
        // query params
        if ($diet !== null) {
            $queryParams['diet'] = ObjectSerializer::toQueryValue($diet);
        }
        // query params
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generateShoppingList
     *
     * Generate Shopping List
     *
     * @param  string $username The username. (required)
     * @param  string $start_date The start date in the format yyyy-mm-dd. (required)
     * @param  string $end_date The end date in the format yyyy-mm-dd. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject13 $inline_object13 inline_object13 (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function generateShoppingList($username, $start_date, $end_date, $hash, $inline_object13)
    {
        list($response) = $this->generateShoppingListWithHttpInfo($username, $start_date, $end_date, $hash, $inline_object13);
        return $response;
    }

    /**
     * Operation generateShoppingListWithHttpInfo
     *
     * Generate Shopping List
     *
     * @param  string $username The username. (required)
     * @param  string $start_date The start date in the format yyyy-mm-dd. (required)
     * @param  string $end_date The end date in the format yyyy-mm-dd. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject13 $inline_object13 (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function generateShoppingListWithHttpInfo($username, $start_date, $end_date, $hash, $inline_object13)
    {
        $request = $this->generateShoppingListRequest($username, $start_date, $end_date, $hash, $inline_object13);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation generateShoppingListAsync
     *
     * Generate Shopping List
     *
     * @param  string $username The username. (required)
     * @param  string $start_date The start date in the format yyyy-mm-dd. (required)
     * @param  string $end_date The end date in the format yyyy-mm-dd. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject13 $inline_object13 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateShoppingListAsync($username, $start_date, $end_date, $hash, $inline_object13)
    {
        return $this->generateShoppingListAsyncWithHttpInfo($username, $start_date, $end_date, $hash, $inline_object13)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generateShoppingListAsyncWithHttpInfo
     *
     * Generate Shopping List
     *
     * @param  string $username The username. (required)
     * @param  string $start_date The start date in the format yyyy-mm-dd. (required)
     * @param  string $end_date The end date in the format yyyy-mm-dd. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject13 $inline_object13 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateShoppingListAsyncWithHttpInfo($username, $start_date, $end_date, $hash, $inline_object13)
    {
        $returnType = 'object';
        $request = $this->generateShoppingListRequest($username, $start_date, $end_date, $hash, $inline_object13);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generateShoppingList'
     *
     * @param  string $username The username. (required)
     * @param  string $start_date The start date in the format yyyy-mm-dd. (required)
     * @param  string $end_date The end date in the format yyyy-mm-dd. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject13 $inline_object13 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function generateShoppingListRequest($username, $start_date, $end_date, $hash, $inline_object13)
    {
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling generateShoppingList'
            );
        }
        // verify the required parameter 'start_date' is set
        if ($start_date === null || (is_array($start_date) && count($start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_date when calling generateShoppingList'
            );
        }
        // verify the required parameter 'end_date' is set
        if ($end_date === null || (is_array($end_date) && count($end_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $end_date when calling generateShoppingList'
            );
        }
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling generateShoppingList'
            );
        }
        // verify the required parameter 'inline_object13' is set
        if ($inline_object13 === null || (is_array($inline_object13) && count($inline_object13) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inline_object13 when calling generateShoppingList'
            );
        }

        $resourcePath = '/mealplanner/{username}/shopping-list/{start-date}/{end-date}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($hash !== null) {
            $queryParams['hash'] = ObjectSerializer::toQueryValue($hash);
        }

        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }
        // path params
        if ($start_date !== null) {
            $resourcePath = str_replace(
                '{' . 'start-date' . '}',
                ObjectSerializer::toPathValue($start_date),
                $resourcePath
            );
        }
        // path params
        if ($end_date !== null) {
            $resourcePath = str_replace(
                '{' . 'end-date' . '}',
                ObjectSerializer::toPathValue($end_date),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($inline_object13)) {
            $_tempBody = $inline_object13;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getARandomFoodJoke
     *
     * Get a Random Food Joke
     *
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getARandomFoodJoke()
    {
        list($response) = $this->getARandomFoodJokeWithHttpInfo();
        return $response;
    }

    /**
     * Operation getARandomFoodJokeWithHttpInfo
     *
     * Get a Random Food Joke
     *
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getARandomFoodJokeWithHttpInfo()
    {
        $request = $this->getARandomFoodJokeRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getARandomFoodJokeAsync
     *
     * Get a Random Food Joke
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getARandomFoodJokeAsync()
    {
        return $this->getARandomFoodJokeAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getARandomFoodJokeAsyncWithHttpInfo
     *
     * Get a Random Food Joke
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getARandomFoodJokeAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->getARandomFoodJokeRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getARandomFoodJoke'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getARandomFoodJokeRequest()
    {

        $resourcePath = '/food/jokes/random';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnalyzedRecipeInstructions
     *
     * Get Analyzed Recipe Instructions
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getAnalyzedRecipeInstructions($id, $step_breakdown = null)
    {
        list($response) = $this->getAnalyzedRecipeInstructionsWithHttpInfo($id, $step_breakdown);
        return $response;
    }

    /**
     * Operation getAnalyzedRecipeInstructionsWithHttpInfo
     *
     * Get Analyzed Recipe Instructions
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnalyzedRecipeInstructionsWithHttpInfo($id, $step_breakdown = null)
    {
        $request = $this->getAnalyzedRecipeInstructionsRequest($id, $step_breakdown);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAnalyzedRecipeInstructionsAsync
     *
     * Get Analyzed Recipe Instructions
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnalyzedRecipeInstructionsAsync($id, $step_breakdown = null)
    {
        return $this->getAnalyzedRecipeInstructionsAsyncWithHttpInfo($id, $step_breakdown)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnalyzedRecipeInstructionsAsyncWithHttpInfo
     *
     * Get Analyzed Recipe Instructions
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnalyzedRecipeInstructionsAsyncWithHttpInfo($id, $step_breakdown = null)
    {
        $returnType = 'object';
        $request = $this->getAnalyzedRecipeInstructionsRequest($id, $step_breakdown);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnalyzedRecipeInstructions'
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAnalyzedRecipeInstructionsRequest($id, $step_breakdown = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAnalyzedRecipeInstructions'
            );
        }

        $resourcePath = '/recipes/{id}/analyzedInstructions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($step_breakdown !== null) {
            $queryParams['stepBreakdown'] = ObjectSerializer::toQueryValue($step_breakdown);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getComparableProducts
     *
     * Get Comparable Products
     *
     * @param  float $upc The UPC of the product for which you want to find comparable products. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getComparableProducts($upc)
    {
        list($response) = $this->getComparableProductsWithHttpInfo($upc);
        return $response;
    }

    /**
     * Operation getComparableProductsWithHttpInfo
     *
     * Get Comparable Products
     *
     * @param  float $upc The UPC of the product for which you want to find comparable products. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getComparableProductsWithHttpInfo($upc)
    {
        $request = $this->getComparableProductsRequest($upc);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getComparableProductsAsync
     *
     * Get Comparable Products
     *
     * @param  float $upc The UPC of the product for which you want to find comparable products. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getComparableProductsAsync($upc)
    {
        return $this->getComparableProductsAsyncWithHttpInfo($upc)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getComparableProductsAsyncWithHttpInfo
     *
     * Get Comparable Products
     *
     * @param  float $upc The UPC of the product for which you want to find comparable products. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getComparableProductsAsyncWithHttpInfo($upc)
    {
        $returnType = 'object';
        $request = $this->getComparableProductsRequest($upc);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getComparableProducts'
     *
     * @param  float $upc The UPC of the product for which you want to find comparable products. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getComparableProductsRequest($upc)
    {
        // verify the required parameter 'upc' is set
        if ($upc === null || (is_array($upc) && count($upc) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $upc when calling getComparableProducts'
            );
        }

        $resourcePath = '/food/products/upc/{upc}/comparable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($upc !== null) {
            $resourcePath = str_replace(
                '{' . 'upc' . '}',
                ObjectSerializer::toPathValue($upc),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversationSuggests
     *
     * Get Conversation Suggests
     *
     * @param  string $query A (partial) query from the user. The endpoint will return if it matches topics it can talk about. (required)
     * @param  float $number The number of suggestions to return (between 1 and 25). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getConversationSuggests($query, $number = null)
    {
        list($response) = $this->getConversationSuggestsWithHttpInfo($query, $number);
        return $response;
    }

    /**
     * Operation getConversationSuggestsWithHttpInfo
     *
     * Get Conversation Suggests
     *
     * @param  string $query A (partial) query from the user. The endpoint will return if it matches topics it can talk about. (required)
     * @param  float $number The number of suggestions to return (between 1 and 25). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationSuggestsWithHttpInfo($query, $number = null)
    {
        $request = $this->getConversationSuggestsRequest($query, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationSuggestsAsync
     *
     * Get Conversation Suggests
     *
     * @param  string $query A (partial) query from the user. The endpoint will return if it matches topics it can talk about. (required)
     * @param  float $number The number of suggestions to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationSuggestsAsync($query, $number = null)
    {
        return $this->getConversationSuggestsAsyncWithHttpInfo($query, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationSuggestsAsyncWithHttpInfo
     *
     * Get Conversation Suggests
     *
     * @param  string $query A (partial) query from the user. The endpoint will return if it matches topics it can talk about. (required)
     * @param  float $number The number of suggestions to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationSuggestsAsyncWithHttpInfo($query, $number = null)
    {
        $returnType = 'object';
        $request = $this->getConversationSuggestsRequest($query, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversationSuggests'
     *
     * @param  string $query A (partial) query from the user. The endpoint will return if it matches topics it can talk about. (required)
     * @param  float $number The number of suggestions to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConversationSuggestsRequest($query, $number = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling getConversationSuggests'
            );
        }

        $resourcePath = '/food/converse/suggest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDishPairingForWine
     *
     * Get Dish Pairing for Wine
     *
     * @param  string $wine The type of wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDishPairingForWine($wine)
    {
        list($response) = $this->getDishPairingForWineWithHttpInfo($wine);
        return $response;
    }

    /**
     * Operation getDishPairingForWineWithHttpInfo
     *
     * Get Dish Pairing for Wine
     *
     * @param  string $wine The type of wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDishPairingForWineWithHttpInfo($wine)
    {
        $request = $this->getDishPairingForWineRequest($wine);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDishPairingForWineAsync
     *
     * Get Dish Pairing for Wine
     *
     * @param  string $wine The type of wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDishPairingForWineAsync($wine)
    {
        return $this->getDishPairingForWineAsyncWithHttpInfo($wine)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDishPairingForWineAsyncWithHttpInfo
     *
     * Get Dish Pairing for Wine
     *
     * @param  string $wine The type of wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDishPairingForWineAsyncWithHttpInfo($wine)
    {
        $returnType = 'object';
        $request = $this->getDishPairingForWineRequest($wine);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDishPairingForWine'
     *
     * @param  string $wine The type of wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDishPairingForWineRequest($wine)
    {
        // verify the required parameter 'wine' is set
        if ($wine === null || (is_array($wine) && count($wine) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wine when calling getDishPairingForWine'
            );
        }

        $resourcePath = '/food/wine/dishes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($wine !== null) {
            $queryParams['wine'] = ObjectSerializer::toQueryValue($wine);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIngredientInformation
     *
     * Get Ingredient Information
     *
     * @param  float $id The ingredient id. (required)
     * @param  float $amount The amount of this ingredient. (optional)
     * @param  string $unit The unit for the given amount. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getIngredientInformation($id, $amount = null, $unit = null)
    {
        list($response) = $this->getIngredientInformationWithHttpInfo($id, $amount, $unit);
        return $response;
    }

    /**
     * Operation getIngredientInformationWithHttpInfo
     *
     * Get Ingredient Information
     *
     * @param  float $id The ingredient id. (required)
     * @param  float $amount The amount of this ingredient. (optional)
     * @param  string $unit The unit for the given amount. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getIngredientInformationWithHttpInfo($id, $amount = null, $unit = null)
    {
        $request = $this->getIngredientInformationRequest($id, $amount, $unit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getIngredientInformationAsync
     *
     * Get Ingredient Information
     *
     * @param  float $id The ingredient id. (required)
     * @param  float $amount The amount of this ingredient. (optional)
     * @param  string $unit The unit for the given amount. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIngredientInformationAsync($id, $amount = null, $unit = null)
    {
        return $this->getIngredientInformationAsyncWithHttpInfo($id, $amount, $unit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIngredientInformationAsyncWithHttpInfo
     *
     * Get Ingredient Information
     *
     * @param  float $id The ingredient id. (required)
     * @param  float $amount The amount of this ingredient. (optional)
     * @param  string $unit The unit for the given amount. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIngredientInformationAsyncWithHttpInfo($id, $amount = null, $unit = null)
    {
        $returnType = 'object';
        $request = $this->getIngredientInformationRequest($id, $amount, $unit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIngredientInformation'
     *
     * @param  float $id The ingredient id. (required)
     * @param  float $amount The amount of this ingredient. (optional)
     * @param  string $unit The unit for the given amount. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getIngredientInformationRequest($id, $amount = null, $unit = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getIngredientInformation'
            );
        }

        $resourcePath = '/food/ingredients/{id}/information';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($amount !== null) {
            $queryParams['amount'] = ObjectSerializer::toQueryValue($amount);
        }
        // query params
        if ($unit !== null) {
            $queryParams['unit'] = ObjectSerializer::toQueryValue($unit);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIngredientSubstitutes
     *
     * Get Ingredient Substitutes
     *
     * @param  string $ingredient_name The name of the ingredient you want to replace. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getIngredientSubstitutes($ingredient_name)
    {
        list($response) = $this->getIngredientSubstitutesWithHttpInfo($ingredient_name);
        return $response;
    }

    /**
     * Operation getIngredientSubstitutesWithHttpInfo
     *
     * Get Ingredient Substitutes
     *
     * @param  string $ingredient_name The name of the ingredient you want to replace. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getIngredientSubstitutesWithHttpInfo($ingredient_name)
    {
        $request = $this->getIngredientSubstitutesRequest($ingredient_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getIngredientSubstitutesAsync
     *
     * Get Ingredient Substitutes
     *
     * @param  string $ingredient_name The name of the ingredient you want to replace. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIngredientSubstitutesAsync($ingredient_name)
    {
        return $this->getIngredientSubstitutesAsyncWithHttpInfo($ingredient_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIngredientSubstitutesAsyncWithHttpInfo
     *
     * Get Ingredient Substitutes
     *
     * @param  string $ingredient_name The name of the ingredient you want to replace. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIngredientSubstitutesAsyncWithHttpInfo($ingredient_name)
    {
        $returnType = 'object';
        $request = $this->getIngredientSubstitutesRequest($ingredient_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIngredientSubstitutes'
     *
     * @param  string $ingredient_name The name of the ingredient you want to replace. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getIngredientSubstitutesRequest($ingredient_name)
    {
        // verify the required parameter 'ingredient_name' is set
        if ($ingredient_name === null || (is_array($ingredient_name) && count($ingredient_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_name when calling getIngredientSubstitutes'
            );
        }

        $resourcePath = '/food/ingredients/substitutes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ingredient_name !== null) {
            $queryParams['ingredientName'] = ObjectSerializer::toQueryValue($ingredient_name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIngredientSubstitutesByID
     *
     * Get Ingredient Substitutes by ID
     *
     * @param  float $id The id of the ingredient you want substitutes for. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getIngredientSubstitutesByID($id)
    {
        list($response) = $this->getIngredientSubstitutesByIDWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getIngredientSubstitutesByIDWithHttpInfo
     *
     * Get Ingredient Substitutes by ID
     *
     * @param  float $id The id of the ingredient you want substitutes for. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getIngredientSubstitutesByIDWithHttpInfo($id)
    {
        $request = $this->getIngredientSubstitutesByIDRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getIngredientSubstitutesByIDAsync
     *
     * Get Ingredient Substitutes by ID
     *
     * @param  float $id The id of the ingredient you want substitutes for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIngredientSubstitutesByIDAsync($id)
    {
        return $this->getIngredientSubstitutesByIDAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIngredientSubstitutesByIDAsyncWithHttpInfo
     *
     * Get Ingredient Substitutes by ID
     *
     * @param  float $id The id of the ingredient you want substitutes for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIngredientSubstitutesByIDAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->getIngredientSubstitutesByIDRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIngredientSubstitutesByID'
     *
     * @param  float $id The id of the ingredient you want substitutes for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getIngredientSubstitutesByIDRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getIngredientSubstitutesByID'
            );
        }

        $resourcePath = '/food/ingredients/{id}/substitutes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMealPlanTemplate
     *
     * Get Meal Plan Template
     *
     * @param  string $username The username. (required)
     * @param  float $id The shopping list item id. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getMealPlanTemplate($username, $id, $hash)
    {
        list($response) = $this->getMealPlanTemplateWithHttpInfo($username, $id, $hash);
        return $response;
    }

    /**
     * Operation getMealPlanTemplateWithHttpInfo
     *
     * Get Meal Plan Template
     *
     * @param  string $username The username. (required)
     * @param  float $id The shopping list item id. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMealPlanTemplateWithHttpInfo($username, $id, $hash)
    {
        $request = $this->getMealPlanTemplateRequest($username, $id, $hash);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMealPlanTemplateAsync
     *
     * Get Meal Plan Template
     *
     * @param  string $username The username. (required)
     * @param  float $id The shopping list item id. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMealPlanTemplateAsync($username, $id, $hash)
    {
        return $this->getMealPlanTemplateAsyncWithHttpInfo($username, $id, $hash)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMealPlanTemplateAsyncWithHttpInfo
     *
     * Get Meal Plan Template
     *
     * @param  string $username The username. (required)
     * @param  float $id The shopping list item id. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMealPlanTemplateAsyncWithHttpInfo($username, $id, $hash)
    {
        $returnType = 'object';
        $request = $this->getMealPlanTemplateRequest($username, $id, $hash);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMealPlanTemplate'
     *
     * @param  string $username The username. (required)
     * @param  float $id The shopping list item id. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMealPlanTemplateRequest($username, $id, $hash)
    {
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling getMealPlanTemplate'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getMealPlanTemplate'
            );
        }
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling getMealPlanTemplate'
            );
        }

        $resourcePath = '/mealplanner/{username}/templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($hash !== null) {
            $queryParams['hash'] = ObjectSerializer::toQueryValue($hash);
        }

        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMealPlanTemplates
     *
     * Get Meal Plan Templates
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getMealPlanTemplates($username, $hash)
    {
        list($response) = $this->getMealPlanTemplatesWithHttpInfo($username, $hash);
        return $response;
    }

    /**
     * Operation getMealPlanTemplatesWithHttpInfo
     *
     * Get Meal Plan Templates
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMealPlanTemplatesWithHttpInfo($username, $hash)
    {
        $request = $this->getMealPlanTemplatesRequest($username, $hash);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMealPlanTemplatesAsync
     *
     * Get Meal Plan Templates
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMealPlanTemplatesAsync($username, $hash)
    {
        return $this->getMealPlanTemplatesAsyncWithHttpInfo($username, $hash)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMealPlanTemplatesAsyncWithHttpInfo
     *
     * Get Meal Plan Templates
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMealPlanTemplatesAsyncWithHttpInfo($username, $hash)
    {
        $returnType = 'object';
        $request = $this->getMealPlanTemplatesRequest($username, $hash);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMealPlanTemplates'
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMealPlanTemplatesRequest($username, $hash)
    {
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling getMealPlanTemplates'
            );
        }
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling getMealPlanTemplates'
            );
        }

        $resourcePath = '/mealplanner/{username}/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($hash !== null) {
            $queryParams['hash'] = ObjectSerializer::toQueryValue($hash);
        }

        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMealPlanWeek
     *
     * Get Meal Plan Week
     *
     * @param  string $username The username. (required)
     * @param  string $start_date The start date of the meal planned week in the format yyyy-mm-dd. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getMealPlanWeek($username, $start_date, $hash)
    {
        list($response) = $this->getMealPlanWeekWithHttpInfo($username, $start_date, $hash);
        return $response;
    }

    /**
     * Operation getMealPlanWeekWithHttpInfo
     *
     * Get Meal Plan Week
     *
     * @param  string $username The username. (required)
     * @param  string $start_date The start date of the meal planned week in the format yyyy-mm-dd. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMealPlanWeekWithHttpInfo($username, $start_date, $hash)
    {
        $request = $this->getMealPlanWeekRequest($username, $start_date, $hash);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMealPlanWeekAsync
     *
     * Get Meal Plan Week
     *
     * @param  string $username The username. (required)
     * @param  string $start_date The start date of the meal planned week in the format yyyy-mm-dd. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMealPlanWeekAsync($username, $start_date, $hash)
    {
        return $this->getMealPlanWeekAsyncWithHttpInfo($username, $start_date, $hash)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMealPlanWeekAsyncWithHttpInfo
     *
     * Get Meal Plan Week
     *
     * @param  string $username The username. (required)
     * @param  string $start_date The start date of the meal planned week in the format yyyy-mm-dd. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMealPlanWeekAsyncWithHttpInfo($username, $start_date, $hash)
    {
        $returnType = 'object';
        $request = $this->getMealPlanWeekRequest($username, $start_date, $hash);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMealPlanWeek'
     *
     * @param  string $username The username. (required)
     * @param  string $start_date The start date of the meal planned week in the format yyyy-mm-dd. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMealPlanWeekRequest($username, $start_date, $hash)
    {
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling getMealPlanWeek'
            );
        }
        // verify the required parameter 'start_date' is set
        if ($start_date === null || (is_array($start_date) && count($start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_date when calling getMealPlanWeek'
            );
        }
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling getMealPlanWeek'
            );
        }

        $resourcePath = '/mealplanner/{username}/week/{start-date}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($hash !== null) {
            $queryParams['hash'] = ObjectSerializer::toQueryValue($hash);
        }

        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }
        // path params
        if ($start_date !== null) {
            $resourcePath = str_replace(
                '{' . 'start-date' . '}',
                ObjectSerializer::toPathValue($start_date),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMenuItemInformation
     *
     * Get Menu Item Information
     *
     * @param  float $id The menu item id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getMenuItemInformation($id)
    {
        list($response) = $this->getMenuItemInformationWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getMenuItemInformationWithHttpInfo
     *
     * Get Menu Item Information
     *
     * @param  float $id The menu item id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMenuItemInformationWithHttpInfo($id)
    {
        $request = $this->getMenuItemInformationRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMenuItemInformationAsync
     *
     * Get Menu Item Information
     *
     * @param  float $id The menu item id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMenuItemInformationAsync($id)
    {
        return $this->getMenuItemInformationAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMenuItemInformationAsyncWithHttpInfo
     *
     * Get Menu Item Information
     *
     * @param  float $id The menu item id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMenuItemInformationAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->getMenuItemInformationRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMenuItemInformation'
     *
     * @param  float $id The menu item id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMenuItemInformationRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getMenuItemInformation'
            );
        }

        $resourcePath = '/food/menuItems/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProductInformation
     *
     * Get Product Information
     *
     * @param  float $id The id of the packaged food. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getProductInformation($id)
    {
        list($response) = $this->getProductInformationWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getProductInformationWithHttpInfo
     *
     * Get Product Information
     *
     * @param  float $id The id of the packaged food. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProductInformationWithHttpInfo($id)
    {
        $request = $this->getProductInformationRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProductInformationAsync
     *
     * Get Product Information
     *
     * @param  float $id The id of the packaged food. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductInformationAsync($id)
    {
        return $this->getProductInformationAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProductInformationAsyncWithHttpInfo
     *
     * Get Product Information
     *
     * @param  float $id The id of the packaged food. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductInformationAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->getProductInformationRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProductInformation'
     *
     * @param  float $id The id of the packaged food. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProductInformationRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getProductInformation'
            );
        }

        $resourcePath = '/food/products/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRandomFoodTrivia
     *
     * Get Random Food Trivia
     *
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getRandomFoodTrivia()
    {
        list($response) = $this->getRandomFoodTriviaWithHttpInfo();
        return $response;
    }

    /**
     * Operation getRandomFoodTriviaWithHttpInfo
     *
     * Get Random Food Trivia
     *
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRandomFoodTriviaWithHttpInfo()
    {
        $request = $this->getRandomFoodTriviaRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRandomFoodTriviaAsync
     *
     * Get Random Food Trivia
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRandomFoodTriviaAsync()
    {
        return $this->getRandomFoodTriviaAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRandomFoodTriviaAsyncWithHttpInfo
     *
     * Get Random Food Trivia
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRandomFoodTriviaAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->getRandomFoodTriviaRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRandomFoodTrivia'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRandomFoodTriviaRequest()
    {

        $resourcePath = '/food/trivia/random';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRandomRecipes
     *
     * Get Random Recipes
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getRandomRecipes($limit_license = null, $tags = null, $number = null)
    {
        list($response) = $this->getRandomRecipesWithHttpInfo($limit_license, $tags, $number);
        return $response;
    }

    /**
     * Operation getRandomRecipesWithHttpInfo
     *
     * Get Random Recipes
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRandomRecipesWithHttpInfo($limit_license = null, $tags = null, $number = null)
    {
        $request = $this->getRandomRecipesRequest($limit_license, $tags, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRandomRecipesAsync
     *
     * Get Random Recipes
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRandomRecipesAsync($limit_license = null, $tags = null, $number = null)
    {
        return $this->getRandomRecipesAsyncWithHttpInfo($limit_license, $tags, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRandomRecipesAsyncWithHttpInfo
     *
     * Get Random Recipes
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRandomRecipesAsyncWithHttpInfo($limit_license = null, $tags = null, $number = null)
    {
        $returnType = 'object';
        $request = $this->getRandomRecipesRequest($limit_license, $tags, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRandomRecipes'
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRandomRecipesRequest($limit_license = null, $tags = null, $number = null)
    {

        $resourcePath = '/recipes/random';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit_license !== null) {
            $queryParams['limitLicense'] = ObjectSerializer::toQueryValue($limit_license);
        }
        // query params
        if ($tags !== null) {
            $queryParams['tags'] = ObjectSerializer::toQueryValue($tags);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeEquipmentByID
     *
     * Get Recipe Equipment by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getRecipeEquipmentByID($id)
    {
        list($response) = $this->getRecipeEquipmentByIDWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRecipeEquipmentByIDWithHttpInfo
     *
     * Get Recipe Equipment by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeEquipmentByIDWithHttpInfo($id)
    {
        $request = $this->getRecipeEquipmentByIDRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeEquipmentByIDAsync
     *
     * Get Recipe Equipment by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeEquipmentByIDAsync($id)
    {
        return $this->getRecipeEquipmentByIDAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeEquipmentByIDAsyncWithHttpInfo
     *
     * Get Recipe Equipment by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeEquipmentByIDAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->getRecipeEquipmentByIDRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeEquipmentByID'
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRecipeEquipmentByIDRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeEquipmentByID'
            );
        }

        $resourcePath = '/recipes/{id}/equipmentWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeInformation
     *
     * Get Recipe Information
     *
     * @param  float $id The id of the recipe. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getRecipeInformation($id, $include_nutrition = null)
    {
        list($response) = $this->getRecipeInformationWithHttpInfo($id, $include_nutrition);
        return $response;
    }

    /**
     * Operation getRecipeInformationWithHttpInfo
     *
     * Get Recipe Information
     *
     * @param  float $id The id of the recipe. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeInformationWithHttpInfo($id, $include_nutrition = null)
    {
        $request = $this->getRecipeInformationRequest($id, $include_nutrition);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeInformationAsync
     *
     * Get Recipe Information
     *
     * @param  float $id The id of the recipe. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeInformationAsync($id, $include_nutrition = null)
    {
        return $this->getRecipeInformationAsyncWithHttpInfo($id, $include_nutrition)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeInformationAsyncWithHttpInfo
     *
     * Get Recipe Information
     *
     * @param  float $id The id of the recipe. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeInformationAsyncWithHttpInfo($id, $include_nutrition = null)
    {
        $returnType = 'object';
        $request = $this->getRecipeInformationRequest($id, $include_nutrition);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeInformation'
     *
     * @param  float $id The id of the recipe. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRecipeInformationRequest($id, $include_nutrition = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeInformation'
            );
        }

        $resourcePath = '/recipes/{id}/information';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_nutrition !== null) {
            $queryParams['includeNutrition'] = ObjectSerializer::toQueryValue($include_nutrition);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeInformationBulk
     *
     * Get Recipe Information Bulk
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data to the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getRecipeInformationBulk($ids, $include_nutrition = null)
    {
        list($response) = $this->getRecipeInformationBulkWithHttpInfo($ids, $include_nutrition);
        return $response;
    }

    /**
     * Operation getRecipeInformationBulkWithHttpInfo
     *
     * Get Recipe Information Bulk
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data to the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeInformationBulkWithHttpInfo($ids, $include_nutrition = null)
    {
        $request = $this->getRecipeInformationBulkRequest($ids, $include_nutrition);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeInformationBulkAsync
     *
     * Get Recipe Information Bulk
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data to the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeInformationBulkAsync($ids, $include_nutrition = null)
    {
        return $this->getRecipeInformationBulkAsyncWithHttpInfo($ids, $include_nutrition)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeInformationBulkAsyncWithHttpInfo
     *
     * Get Recipe Information Bulk
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data to the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeInformationBulkAsyncWithHttpInfo($ids, $include_nutrition = null)
    {
        $returnType = 'object';
        $request = $this->getRecipeInformationBulkRequest($ids, $include_nutrition);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeInformationBulk'
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data to the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRecipeInformationBulkRequest($ids, $include_nutrition = null)
    {
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling getRecipeInformationBulk'
            );
        }

        $resourcePath = '/recipes/informationBulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ids !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($ids);
        }
        // query params
        if ($include_nutrition !== null) {
            $queryParams['includeNutrition'] = ObjectSerializer::toQueryValue($include_nutrition);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeIngredientsByID
     *
     * Get Recipe Ingredients by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getRecipeIngredientsByID($id)
    {
        list($response) = $this->getRecipeIngredientsByIDWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRecipeIngredientsByIDWithHttpInfo
     *
     * Get Recipe Ingredients by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeIngredientsByIDWithHttpInfo($id)
    {
        $request = $this->getRecipeIngredientsByIDRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeIngredientsByIDAsync
     *
     * Get Recipe Ingredients by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeIngredientsByIDAsync($id)
    {
        return $this->getRecipeIngredientsByIDAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeIngredientsByIDAsyncWithHttpInfo
     *
     * Get Recipe Ingredients by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeIngredientsByIDAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->getRecipeIngredientsByIDRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeIngredientsByID'
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRecipeIngredientsByIDRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeIngredientsByID'
            );
        }

        $resourcePath = '/recipes/{id}/ingredientWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeNutritionWidgetByID
     *
     * Get Recipe Nutrition Widget by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getRecipeNutritionWidgetByID($id)
    {
        list($response) = $this->getRecipeNutritionWidgetByIDWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRecipeNutritionWidgetByIDWithHttpInfo
     *
     * Get Recipe Nutrition Widget by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeNutritionWidgetByIDWithHttpInfo($id)
    {
        $request = $this->getRecipeNutritionWidgetByIDRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeNutritionWidgetByIDAsync
     *
     * Get Recipe Nutrition Widget by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeNutritionWidgetByIDAsync($id)
    {
        return $this->getRecipeNutritionWidgetByIDAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeNutritionWidgetByIDAsyncWithHttpInfo
     *
     * Get Recipe Nutrition Widget by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeNutritionWidgetByIDAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->getRecipeNutritionWidgetByIDRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeNutritionWidgetByID'
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRecipeNutritionWidgetByIDRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeNutritionWidgetByID'
            );
        }

        $resourcePath = '/recipes/{id}/nutritionWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipePriceBreakdownByID
     *
     * Get Recipe Price Breakdown by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getRecipePriceBreakdownByID($id)
    {
        list($response) = $this->getRecipePriceBreakdownByIDWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRecipePriceBreakdownByIDWithHttpInfo
     *
     * Get Recipe Price Breakdown by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipePriceBreakdownByIDWithHttpInfo($id)
    {
        $request = $this->getRecipePriceBreakdownByIDRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipePriceBreakdownByIDAsync
     *
     * Get Recipe Price Breakdown by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipePriceBreakdownByIDAsync($id)
    {
        return $this->getRecipePriceBreakdownByIDAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipePriceBreakdownByIDAsyncWithHttpInfo
     *
     * Get Recipe Price Breakdown by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipePriceBreakdownByIDAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->getRecipePriceBreakdownByIDRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipePriceBreakdownByID'
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRecipePriceBreakdownByIDRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipePriceBreakdownByID'
            );
        }

        $resourcePath = '/recipes/{id}/priceBreakdownWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeTasteByID
     *
     * Get Recipe Taste by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getRecipeTasteByID($id)
    {
        list($response) = $this->getRecipeTasteByIDWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRecipeTasteByIDWithHttpInfo
     *
     * Get Recipe Taste by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeTasteByIDWithHttpInfo($id)
    {
        $request = $this->getRecipeTasteByIDRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeTasteByIDAsync
     *
     * Get Recipe Taste by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeTasteByIDAsync($id)
    {
        return $this->getRecipeTasteByIDAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeTasteByIDAsyncWithHttpInfo
     *
     * Get Recipe Taste by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeTasteByIDAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->getRecipeTasteByIDRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeTasteByID'
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRecipeTasteByIDRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeTasteByID'
            );
        }

        $resourcePath = '/recipes/{id}/tasteWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getShoppingList
     *
     * Get Shopping List
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getShoppingList($username, $hash)
    {
        list($response) = $this->getShoppingListWithHttpInfo($username, $hash);
        return $response;
    }

    /**
     * Operation getShoppingListWithHttpInfo
     *
     * Get Shopping List
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getShoppingListWithHttpInfo($username, $hash)
    {
        $request = $this->getShoppingListRequest($username, $hash);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getShoppingListAsync
     *
     * Get Shopping List
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getShoppingListAsync($username, $hash)
    {
        return $this->getShoppingListAsyncWithHttpInfo($username, $hash)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getShoppingListAsyncWithHttpInfo
     *
     * Get Shopping List
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getShoppingListAsyncWithHttpInfo($username, $hash)
    {
        $returnType = 'object';
        $request = $this->getShoppingListRequest($username, $hash);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getShoppingList'
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getShoppingListRequest($username, $hash)
    {
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling getShoppingList'
            );
        }
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling getShoppingList'
            );
        }

        $resourcePath = '/mealplanner/{username}/shopping-list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($hash !== null) {
            $queryParams['hash'] = ObjectSerializer::toQueryValue($hash);
        }

        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSimilarRecipes
     *
     * Get Similar Recipes
     *
     * @param  float $id The id of the source recipe for which similar recipes should be found. (required)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getSimilarRecipes($id, $number = null, $limit_license = null)
    {
        list($response) = $this->getSimilarRecipesWithHttpInfo($id, $number, $limit_license);
        return $response;
    }

    /**
     * Operation getSimilarRecipesWithHttpInfo
     *
     * Get Similar Recipes
     *
     * @param  float $id The id of the source recipe for which similar recipes should be found. (required)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSimilarRecipesWithHttpInfo($id, $number = null, $limit_license = null)
    {
        $request = $this->getSimilarRecipesRequest($id, $number, $limit_license);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSimilarRecipesAsync
     *
     * Get Similar Recipes
     *
     * @param  float $id The id of the source recipe for which similar recipes should be found. (required)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSimilarRecipesAsync($id, $number = null, $limit_license = null)
    {
        return $this->getSimilarRecipesAsyncWithHttpInfo($id, $number, $limit_license)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSimilarRecipesAsyncWithHttpInfo
     *
     * Get Similar Recipes
     *
     * @param  float $id The id of the source recipe for which similar recipes should be found. (required)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSimilarRecipesAsyncWithHttpInfo($id, $number = null, $limit_license = null)
    {
        $returnType = 'object';
        $request = $this->getSimilarRecipesRequest($id, $number, $limit_license);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSimilarRecipes'
     *
     * @param  float $id The id of the source recipe for which similar recipes should be found. (required)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSimilarRecipesRequest($id, $number = null, $limit_license = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getSimilarRecipes'
            );
        }

        $resourcePath = '/recipes/{id}/similar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }
        // query params
        if ($limit_license !== null) {
            $queryParams['limitLicense'] = ObjectSerializer::toQueryValue($limit_license);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWineDescription
     *
     * Get Wine Description
     *
     * @param  string $wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getWineDescription($wine)
    {
        list($response) = $this->getWineDescriptionWithHttpInfo($wine);
        return $response;
    }

    /**
     * Operation getWineDescriptionWithHttpInfo
     *
     * Get Wine Description
     *
     * @param  string $wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWineDescriptionWithHttpInfo($wine)
    {
        $request = $this->getWineDescriptionRequest($wine);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWineDescriptionAsync
     *
     * Get Wine Description
     *
     * @param  string $wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWineDescriptionAsync($wine)
    {
        return $this->getWineDescriptionAsyncWithHttpInfo($wine)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWineDescriptionAsyncWithHttpInfo
     *
     * Get Wine Description
     *
     * @param  string $wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWineDescriptionAsyncWithHttpInfo($wine)
    {
        $returnType = 'object';
        $request = $this->getWineDescriptionRequest($wine);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWineDescription'
     *
     * @param  string $wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWineDescriptionRequest($wine)
    {
        // verify the required parameter 'wine' is set
        if ($wine === null || (is_array($wine) && count($wine) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wine when calling getWineDescription'
            );
        }

        $resourcePath = '/food/wine/description';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($wine !== null) {
            $queryParams['wine'] = ObjectSerializer::toQueryValue($wine);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWinePairing
     *
     * Get Wine Pairing
     *
     * @param  string $food The food to get a pairing for. This can be a dish (\&quot;steak\&quot;), an ingredient (\&quot;salmon\&quot;), or a cuisine (\&quot;italian\&quot;). (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getWinePairing($food, $max_price = null)
    {
        list($response) = $this->getWinePairingWithHttpInfo($food, $max_price);
        return $response;
    }

    /**
     * Operation getWinePairingWithHttpInfo
     *
     * Get Wine Pairing
     *
     * @param  string $food The food to get a pairing for. This can be a dish (\&quot;steak\&quot;), an ingredient (\&quot;salmon\&quot;), or a cuisine (\&quot;italian\&quot;). (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWinePairingWithHttpInfo($food, $max_price = null)
    {
        $request = $this->getWinePairingRequest($food, $max_price);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWinePairingAsync
     *
     * Get Wine Pairing
     *
     * @param  string $food The food to get a pairing for. This can be a dish (\&quot;steak\&quot;), an ingredient (\&quot;salmon\&quot;), or a cuisine (\&quot;italian\&quot;). (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWinePairingAsync($food, $max_price = null)
    {
        return $this->getWinePairingAsyncWithHttpInfo($food, $max_price)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWinePairingAsyncWithHttpInfo
     *
     * Get Wine Pairing
     *
     * @param  string $food The food to get a pairing for. This can be a dish (\&quot;steak\&quot;), an ingredient (\&quot;salmon\&quot;), or a cuisine (\&quot;italian\&quot;). (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWinePairingAsyncWithHttpInfo($food, $max_price = null)
    {
        $returnType = 'object';
        $request = $this->getWinePairingRequest($food, $max_price);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWinePairing'
     *
     * @param  string $food The food to get a pairing for. This can be a dish (\&quot;steak\&quot;), an ingredient (\&quot;salmon\&quot;), or a cuisine (\&quot;italian\&quot;). (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWinePairingRequest($food, $max_price = null)
    {
        // verify the required parameter 'food' is set
        if ($food === null || (is_array($food) && count($food) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $food when calling getWinePairing'
            );
        }

        $resourcePath = '/food/wine/pairing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($food !== null) {
            $queryParams['food'] = ObjectSerializer::toQueryValue($food);
        }
        // query params
        if ($max_price !== null) {
            $queryParams['maxPrice'] = ObjectSerializer::toQueryValue($max_price);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWineRecommendation
     *
     * Get Wine Recommendation
     *
     * @param  string $wine The type of wine to get a specific product recommendation for. (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     * @param  float $min_rating The minimum rating of the recommended wine between 0 and 1. For example, 0.8 equals 4 out of 5 stars. (optional)
     * @param  float $number The number of wine recommendations expected (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getWineRecommendation($wine, $max_price = null, $min_rating = null, $number = null)
    {
        list($response) = $this->getWineRecommendationWithHttpInfo($wine, $max_price, $min_rating, $number);
        return $response;
    }

    /**
     * Operation getWineRecommendationWithHttpInfo
     *
     * Get Wine Recommendation
     *
     * @param  string $wine The type of wine to get a specific product recommendation for. (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     * @param  float $min_rating The minimum rating of the recommended wine between 0 and 1. For example, 0.8 equals 4 out of 5 stars. (optional)
     * @param  float $number The number of wine recommendations expected (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWineRecommendationWithHttpInfo($wine, $max_price = null, $min_rating = null, $number = null)
    {
        $request = $this->getWineRecommendationRequest($wine, $max_price, $min_rating, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWineRecommendationAsync
     *
     * Get Wine Recommendation
     *
     * @param  string $wine The type of wine to get a specific product recommendation for. (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     * @param  float $min_rating The minimum rating of the recommended wine between 0 and 1. For example, 0.8 equals 4 out of 5 stars. (optional)
     * @param  float $number The number of wine recommendations expected (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWineRecommendationAsync($wine, $max_price = null, $min_rating = null, $number = null)
    {
        return $this->getWineRecommendationAsyncWithHttpInfo($wine, $max_price, $min_rating, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWineRecommendationAsyncWithHttpInfo
     *
     * Get Wine Recommendation
     *
     * @param  string $wine The type of wine to get a specific product recommendation for. (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     * @param  float $min_rating The minimum rating of the recommended wine between 0 and 1. For example, 0.8 equals 4 out of 5 stars. (optional)
     * @param  float $number The number of wine recommendations expected (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWineRecommendationAsyncWithHttpInfo($wine, $max_price = null, $min_rating = null, $number = null)
    {
        $returnType = 'object';
        $request = $this->getWineRecommendationRequest($wine, $max_price, $min_rating, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWineRecommendation'
     *
     * @param  string $wine The type of wine to get a specific product recommendation for. (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     * @param  float $min_rating The minimum rating of the recommended wine between 0 and 1. For example, 0.8 equals 4 out of 5 stars. (optional)
     * @param  float $number The number of wine recommendations expected (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWineRecommendationRequest($wine, $max_price = null, $min_rating = null, $number = null)
    {
        // verify the required parameter 'wine' is set
        if ($wine === null || (is_array($wine) && count($wine) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wine when calling getWineRecommendation'
            );
        }

        $resourcePath = '/food/wine/recommendation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($wine !== null) {
            $queryParams['wine'] = ObjectSerializer::toQueryValue($wine);
        }
        // query params
        if ($max_price !== null) {
            $queryParams['maxPrice'] = ObjectSerializer::toQueryValue($max_price);
        }
        // query params
        if ($min_rating !== null) {
            $queryParams['minRating'] = ObjectSerializer::toQueryValue($min_rating);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation guessNutritionByDishName
     *
     * Guess Nutrition by Dish Name
     *
     * @param  string $title The title of the dish. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function guessNutritionByDishName($title)
    {
        list($response) = $this->guessNutritionByDishNameWithHttpInfo($title);
        return $response;
    }

    /**
     * Operation guessNutritionByDishNameWithHttpInfo
     *
     * Guess Nutrition by Dish Name
     *
     * @param  string $title The title of the dish. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function guessNutritionByDishNameWithHttpInfo($title)
    {
        $request = $this->guessNutritionByDishNameRequest($title);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation guessNutritionByDishNameAsync
     *
     * Guess Nutrition by Dish Name
     *
     * @param  string $title The title of the dish. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function guessNutritionByDishNameAsync($title)
    {
        return $this->guessNutritionByDishNameAsyncWithHttpInfo($title)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation guessNutritionByDishNameAsyncWithHttpInfo
     *
     * Guess Nutrition by Dish Name
     *
     * @param  string $title The title of the dish. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function guessNutritionByDishNameAsyncWithHttpInfo($title)
    {
        $returnType = 'object';
        $request = $this->guessNutritionByDishNameRequest($title);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'guessNutritionByDishName'
     *
     * @param  string $title The title of the dish. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function guessNutritionByDishNameRequest($title)
    {
        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling guessNutritionByDishName'
            );
        }

        $resourcePath = '/recipes/guessNutrition';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($title !== null) {
            $queryParams['title'] = ObjectSerializer::toQueryValue($title);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageAnalysisByURL
     *
     * Image Analysis by URL
     *
     * @param  string $image_url The URL of the image to be analyzed. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function imageAnalysisByURL($image_url)
    {
        list($response) = $this->imageAnalysisByURLWithHttpInfo($image_url);
        return $response;
    }

    /**
     * Operation imageAnalysisByURLWithHttpInfo
     *
     * Image Analysis by URL
     *
     * @param  string $image_url The URL of the image to be analyzed. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageAnalysisByURLWithHttpInfo($image_url)
    {
        $request = $this->imageAnalysisByURLRequest($image_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageAnalysisByURLAsync
     *
     * Image Analysis by URL
     *
     * @param  string $image_url The URL of the image to be analyzed. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageAnalysisByURLAsync($image_url)
    {
        return $this->imageAnalysisByURLAsyncWithHttpInfo($image_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageAnalysisByURLAsyncWithHttpInfo
     *
     * Image Analysis by URL
     *
     * @param  string $image_url The URL of the image to be analyzed. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageAnalysisByURLAsyncWithHttpInfo($image_url)
    {
        $returnType = 'object';
        $request = $this->imageAnalysisByURLRequest($image_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageAnalysisByURL'
     *
     * @param  string $image_url The URL of the image to be analyzed. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageAnalysisByURLRequest($image_url)
    {
        // verify the required parameter 'image_url' is set
        if ($image_url === null || (is_array($image_url) && count($image_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_url when calling imageAnalysisByURL'
            );
        }

        $resourcePath = '/food/images/analyze';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($image_url !== null) {
            $queryParams['imageUrl'] = ObjectSerializer::toQueryValue($image_url);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageClassificationByURL
     *
     * Image Classification by URL
     *
     * @param  string $image_url The URL of the image to be classified. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function imageClassificationByURL($image_url)
    {
        list($response) = $this->imageClassificationByURLWithHttpInfo($image_url);
        return $response;
    }

    /**
     * Operation imageClassificationByURLWithHttpInfo
     *
     * Image Classification by URL
     *
     * @param  string $image_url The URL of the image to be classified. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageClassificationByURLWithHttpInfo($image_url)
    {
        $request = $this->imageClassificationByURLRequest($image_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageClassificationByURLAsync
     *
     * Image Classification by URL
     *
     * @param  string $image_url The URL of the image to be classified. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageClassificationByURLAsync($image_url)
    {
        return $this->imageClassificationByURLAsyncWithHttpInfo($image_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageClassificationByURLAsyncWithHttpInfo
     *
     * Image Classification by URL
     *
     * @param  string $image_url The URL of the image to be classified. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageClassificationByURLAsyncWithHttpInfo($image_url)
    {
        $returnType = 'object';
        $request = $this->imageClassificationByURLRequest($image_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageClassificationByURL'
     *
     * @param  string $image_url The URL of the image to be classified. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageClassificationByURLRequest($image_url)
    {
        // verify the required parameter 'image_url' is set
        if ($image_url === null || (is_array($image_url) && count($image_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_url when calling imageClassificationByURL'
            );
        }

        $resourcePath = '/food/images/classify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($image_url !== null) {
            $queryParams['imageUrl'] = ObjectSerializer::toQueryValue($image_url);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ingredientSearch
     *
     * Ingredient Search
     *
     * @param  string $query The partial or full ingredient name. (required)
     * @param  bool $add_children Whether to add children of found foods. (optional)
     * @param  float $min_protein_percent The minimum percentage of protein the food must have (between 0 and 100). (optional)
     * @param  float $max_protein_percent The maximum percentage of protein the food can have (between 0 and 100). (optional)
     * @param  float $min_fat_percent The minimum percentage of fat the food must have (between 0 and 100). (optional)
     * @param  float $max_fat_percent The maximum percentage of fat the food can have (between 0 and 100). (optional)
     * @param  float $min_carbs_percent The minimum percentage of carbs the food must have (between 0 and 100). (optional)
     * @param  float $max_carbs_percent The maximum percentage of carbs the food can have (between 0 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function ingredientSearch($query, $add_children = null, $min_protein_percent = null, $max_protein_percent = null, $min_fat_percent = null, $max_fat_percent = null, $min_carbs_percent = null, $max_carbs_percent = null, $meta_information = null, $intolerances = null, $sort = null, $sort_direction = null, $offset = null, $number = null)
    {
        list($response) = $this->ingredientSearchWithHttpInfo($query, $add_children, $min_protein_percent, $max_protein_percent, $min_fat_percent, $max_fat_percent, $min_carbs_percent, $max_carbs_percent, $meta_information, $intolerances, $sort, $sort_direction, $offset, $number);
        return $response;
    }

    /**
     * Operation ingredientSearchWithHttpInfo
     *
     * Ingredient Search
     *
     * @param  string $query The partial or full ingredient name. (required)
     * @param  bool $add_children Whether to add children of found foods. (optional)
     * @param  float $min_protein_percent The minimum percentage of protein the food must have (between 0 and 100). (optional)
     * @param  float $max_protein_percent The maximum percentage of protein the food can have (between 0 and 100). (optional)
     * @param  float $min_fat_percent The minimum percentage of fat the food must have (between 0 and 100). (optional)
     * @param  float $max_fat_percent The maximum percentage of fat the food can have (between 0 and 100). (optional)
     * @param  float $min_carbs_percent The minimum percentage of carbs the food must have (between 0 and 100). (optional)
     * @param  float $max_carbs_percent The maximum percentage of carbs the food can have (between 0 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function ingredientSearchWithHttpInfo($query, $add_children = null, $min_protein_percent = null, $max_protein_percent = null, $min_fat_percent = null, $max_fat_percent = null, $min_carbs_percent = null, $max_carbs_percent = null, $meta_information = null, $intolerances = null, $sort = null, $sort_direction = null, $offset = null, $number = null)
    {
        $request = $this->ingredientSearchRequest($query, $add_children, $min_protein_percent, $max_protein_percent, $min_fat_percent, $max_fat_percent, $min_carbs_percent, $max_carbs_percent, $meta_information, $intolerances, $sort, $sort_direction, $offset, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ingredientSearchAsync
     *
     * Ingredient Search
     *
     * @param  string $query The partial or full ingredient name. (required)
     * @param  bool $add_children Whether to add children of found foods. (optional)
     * @param  float $min_protein_percent The minimum percentage of protein the food must have (between 0 and 100). (optional)
     * @param  float $max_protein_percent The maximum percentage of protein the food can have (between 0 and 100). (optional)
     * @param  float $min_fat_percent The minimum percentage of fat the food must have (between 0 and 100). (optional)
     * @param  float $max_fat_percent The maximum percentage of fat the food can have (between 0 and 100). (optional)
     * @param  float $min_carbs_percent The minimum percentage of carbs the food must have (between 0 and 100). (optional)
     * @param  float $max_carbs_percent The maximum percentage of carbs the food can have (between 0 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ingredientSearchAsync($query, $add_children = null, $min_protein_percent = null, $max_protein_percent = null, $min_fat_percent = null, $max_fat_percent = null, $min_carbs_percent = null, $max_carbs_percent = null, $meta_information = null, $intolerances = null, $sort = null, $sort_direction = null, $offset = null, $number = null)
    {
        return $this->ingredientSearchAsyncWithHttpInfo($query, $add_children, $min_protein_percent, $max_protein_percent, $min_fat_percent, $max_fat_percent, $min_carbs_percent, $max_carbs_percent, $meta_information, $intolerances, $sort, $sort_direction, $offset, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ingredientSearchAsyncWithHttpInfo
     *
     * Ingredient Search
     *
     * @param  string $query The partial or full ingredient name. (required)
     * @param  bool $add_children Whether to add children of found foods. (optional)
     * @param  float $min_protein_percent The minimum percentage of protein the food must have (between 0 and 100). (optional)
     * @param  float $max_protein_percent The maximum percentage of protein the food can have (between 0 and 100). (optional)
     * @param  float $min_fat_percent The minimum percentage of fat the food must have (between 0 and 100). (optional)
     * @param  float $max_fat_percent The maximum percentage of fat the food can have (between 0 and 100). (optional)
     * @param  float $min_carbs_percent The minimum percentage of carbs the food must have (between 0 and 100). (optional)
     * @param  float $max_carbs_percent The maximum percentage of carbs the food can have (between 0 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ingredientSearchAsyncWithHttpInfo($query, $add_children = null, $min_protein_percent = null, $max_protein_percent = null, $min_fat_percent = null, $max_fat_percent = null, $min_carbs_percent = null, $max_carbs_percent = null, $meta_information = null, $intolerances = null, $sort = null, $sort_direction = null, $offset = null, $number = null)
    {
        $returnType = 'object';
        $request = $this->ingredientSearchRequest($query, $add_children, $min_protein_percent, $max_protein_percent, $min_fat_percent, $max_fat_percent, $min_carbs_percent, $max_carbs_percent, $meta_information, $intolerances, $sort, $sort_direction, $offset, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ingredientSearch'
     *
     * @param  string $query The partial or full ingredient name. (required)
     * @param  bool $add_children Whether to add children of found foods. (optional)
     * @param  float $min_protein_percent The minimum percentage of protein the food must have (between 0 and 100). (optional)
     * @param  float $max_protein_percent The maximum percentage of protein the food can have (between 0 and 100). (optional)
     * @param  float $min_fat_percent The minimum percentage of fat the food must have (between 0 and 100). (optional)
     * @param  float $max_fat_percent The maximum percentage of fat the food can have (between 0 and 100). (optional)
     * @param  float $min_carbs_percent The minimum percentage of carbs the food must have (between 0 and 100). (optional)
     * @param  float $max_carbs_percent The maximum percentage of carbs the food can have (between 0 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ingredientSearchRequest($query, $add_children = null, $min_protein_percent = null, $max_protein_percent = null, $min_fat_percent = null, $max_fat_percent = null, $min_carbs_percent = null, $max_carbs_percent = null, $meta_information = null, $intolerances = null, $sort = null, $sort_direction = null, $offset = null, $number = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling ingredientSearch'
            );
        }

        $resourcePath = '/food/ingredients/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($add_children !== null) {
            $queryParams['addChildren'] = ObjectSerializer::toQueryValue($add_children);
        }
        // query params
        if ($min_protein_percent !== null) {
            $queryParams['minProteinPercent'] = ObjectSerializer::toQueryValue($min_protein_percent);
        }
        // query params
        if ($max_protein_percent !== null) {
            $queryParams['maxProteinPercent'] = ObjectSerializer::toQueryValue($max_protein_percent);
        }
        // query params
        if ($min_fat_percent !== null) {
            $queryParams['minFatPercent'] = ObjectSerializer::toQueryValue($min_fat_percent);
        }
        // query params
        if ($max_fat_percent !== null) {
            $queryParams['maxFatPercent'] = ObjectSerializer::toQueryValue($max_fat_percent);
        }
        // query params
        if ($min_carbs_percent !== null) {
            $queryParams['minCarbsPercent'] = ObjectSerializer::toQueryValue($min_carbs_percent);
        }
        // query params
        if ($max_carbs_percent !== null) {
            $queryParams['maxCarbsPercent'] = ObjectSerializer::toQueryValue($max_carbs_percent);
        }
        // query params
        if ($meta_information !== null) {
            $queryParams['metaInformation'] = ObjectSerializer::toQueryValue($meta_information);
        }
        // query params
        if ($intolerances !== null) {
            $queryParams['intolerances'] = ObjectSerializer::toQueryValue($intolerances);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($sort_direction !== null) {
            $queryParams['sortDirection'] = ObjectSerializer::toQueryValue($sort_direction);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mapIngredientsToGroceryProducts
     *
     * Map Ingredients to Grocery Products
     *
     * @param  object $body body (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function mapIngredientsToGroceryProducts($body)
    {
        list($response) = $this->mapIngredientsToGroceryProductsWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation mapIngredientsToGroceryProductsWithHttpInfo
     *
     * Map Ingredients to Grocery Products
     *
     * @param  object $body (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function mapIngredientsToGroceryProductsWithHttpInfo($body)
    {
        $request = $this->mapIngredientsToGroceryProductsRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mapIngredientsToGroceryProductsAsync
     *
     * Map Ingredients to Grocery Products
     *
     * @param  object $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mapIngredientsToGroceryProductsAsync($body)
    {
        return $this->mapIngredientsToGroceryProductsAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mapIngredientsToGroceryProductsAsyncWithHttpInfo
     *
     * Map Ingredients to Grocery Products
     *
     * @param  object $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mapIngredientsToGroceryProductsAsyncWithHttpInfo($body)
    {
        $returnType = 'object';
        $request = $this->mapIngredientsToGroceryProductsRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mapIngredientsToGroceryProducts'
     *
     * @param  object $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function mapIngredientsToGroceryProductsRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling mapIngredientsToGroceryProducts'
            );
        }

        $resourcePath = '/food/ingredients/map';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation parseIngredients
     *
     * Parse Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function parseIngredients($ingredient_list, $servings, $include_nutrition = null)
    {
        list($response) = $this->parseIngredientsWithHttpInfo($ingredient_list, $servings, $include_nutrition);
        return $response;
    }

    /**
     * Operation parseIngredientsWithHttpInfo
     *
     * Parse Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function parseIngredientsWithHttpInfo($ingredient_list, $servings, $include_nutrition = null)
    {
        $request = $this->parseIngredientsRequest($ingredient_list, $servings, $include_nutrition);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation parseIngredientsAsync
     *
     * Parse Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseIngredientsAsync($ingredient_list, $servings, $include_nutrition = null)
    {
        return $this->parseIngredientsAsyncWithHttpInfo($ingredient_list, $servings, $include_nutrition)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation parseIngredientsAsyncWithHttpInfo
     *
     * Parse Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseIngredientsAsyncWithHttpInfo($ingredient_list, $servings, $include_nutrition = null)
    {
        $returnType = 'object';
        $request = $this->parseIngredientsRequest($ingredient_list, $servings, $include_nutrition);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'parseIngredients'
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function parseIngredientsRequest($ingredient_list, $servings, $include_nutrition = null)
    {
        // verify the required parameter 'ingredient_list' is set
        if ($ingredient_list === null || (is_array($ingredient_list) && count($ingredient_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_list when calling parseIngredients'
            );
        }
        // verify the required parameter 'servings' is set
        if ($servings === null || (is_array($servings) && count($servings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $servings when calling parseIngredients'
            );
        }

        $resourcePath = '/recipes/parseIngredients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($ingredient_list !== null) {
            $formParams['ingredientList'] = ObjectSerializer::toFormValue($ingredient_list);
        }
        // form params
        if ($servings !== null) {
            $formParams['servings'] = ObjectSerializer::toFormValue($servings);
        }
        // form params
        if ($include_nutrition !== null) {
            $formParams['includeNutrition'] = ObjectSerializer::toFormValue($include_nutrition);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation quickAnswer
     *
     * Quick Answer
     *
     * @param  string $q The nutrition related question. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function quickAnswer($q)
    {
        list($response) = $this->quickAnswerWithHttpInfo($q);
        return $response;
    }

    /**
     * Operation quickAnswerWithHttpInfo
     *
     * Quick Answer
     *
     * @param  string $q The nutrition related question. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function quickAnswerWithHttpInfo($q)
    {
        $request = $this->quickAnswerRequest($q);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation quickAnswerAsync
     *
     * Quick Answer
     *
     * @param  string $q The nutrition related question. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickAnswerAsync($q)
    {
        return $this->quickAnswerAsyncWithHttpInfo($q)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation quickAnswerAsyncWithHttpInfo
     *
     * Quick Answer
     *
     * @param  string $q The nutrition related question. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickAnswerAsyncWithHttpInfo($q)
    {
        $returnType = 'object';
        $request = $this->quickAnswerRequest($q);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'quickAnswer'
     *
     * @param  string $q The nutrition related question. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function quickAnswerRequest($q)
    {
        // verify the required parameter 'q' is set
        if ($q === null || (is_array($q) && count($q) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $q when calling quickAnswer'
            );
        }

        $resourcePath = '/recipes/quickAnswer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($q !== null) {
            $queryParams['q'] = ObjectSerializer::toQueryValue($q);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchAllFood
     *
     * Search All Food
     *
     * @param  string $query The search query. (required)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchAllFood($query, $offset = null, $number = null)
    {
        list($response) = $this->searchAllFoodWithHttpInfo($query, $offset, $number);
        return $response;
    }

    /**
     * Operation searchAllFoodWithHttpInfo
     *
     * Search All Food
     *
     * @param  string $query The search query. (required)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchAllFoodWithHttpInfo($query, $offset = null, $number = null)
    {
        $request = $this->searchAllFoodRequest($query, $offset, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchAllFoodAsync
     *
     * Search All Food
     *
     * @param  string $query The search query. (required)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAllFoodAsync($query, $offset = null, $number = null)
    {
        return $this->searchAllFoodAsyncWithHttpInfo($query, $offset, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchAllFoodAsyncWithHttpInfo
     *
     * Search All Food
     *
     * @param  string $query The search query. (required)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAllFoodAsyncWithHttpInfo($query, $offset = null, $number = null)
    {
        $returnType = 'object';
        $request = $this->searchAllFoodRequest($query, $offset, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchAllFood'
     *
     * @param  string $query The search query. (required)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchAllFoodRequest($query, $offset = null, $number = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchAllFood'
            );
        }

        $resourcePath = '/food/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchCustomFoods
     *
     * Search Custom Foods
     *
     * @param  string $query The search query. (required)
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchCustomFoods($query, $username, $hash, $offset = null, $number = null)
    {
        list($response) = $this->searchCustomFoodsWithHttpInfo($query, $username, $hash, $offset, $number);
        return $response;
    }

    /**
     * Operation searchCustomFoodsWithHttpInfo
     *
     * Search Custom Foods
     *
     * @param  string $query The search query. (required)
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchCustomFoodsWithHttpInfo($query, $username, $hash, $offset = null, $number = null)
    {
        $request = $this->searchCustomFoodsRequest($query, $username, $hash, $offset, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchCustomFoodsAsync
     *
     * Search Custom Foods
     *
     * @param  string $query The search query. (required)
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCustomFoodsAsync($query, $username, $hash, $offset = null, $number = null)
    {
        return $this->searchCustomFoodsAsyncWithHttpInfo($query, $username, $hash, $offset, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchCustomFoodsAsyncWithHttpInfo
     *
     * Search Custom Foods
     *
     * @param  string $query The search query. (required)
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCustomFoodsAsyncWithHttpInfo($query, $username, $hash, $offset = null, $number = null)
    {
        $returnType = 'object';
        $request = $this->searchCustomFoodsRequest($query, $username, $hash, $offset, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchCustomFoods'
     *
     * @param  string $query The search query. (required)
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchCustomFoodsRequest($query, $username, $hash, $offset = null, $number = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchCustomFoods'
            );
        }
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling searchCustomFoods'
            );
        }
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling searchCustomFoods'
            );
        }

        $resourcePath = '/food/customFoods/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($username !== null) {
            $queryParams['username'] = ObjectSerializer::toQueryValue($username);
        }
        // query params
        if ($hash !== null) {
            $queryParams['hash'] = ObjectSerializer::toQueryValue($hash);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchFoodVideos
     *
     * Search Food Videos
     *
     * @param  string $query The search query. (required)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  float $min_length Minimum video length in seconds. (optional)
     * @param  float $max_length Maximum video length in seconds. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchFoodVideos($query, $type = null, $cuisine = null, $diet = null, $include_ingredients = null, $exclude_ingredients = null, $min_length = null, $max_length = null, $offset = null, $number = null)
    {
        list($response) = $this->searchFoodVideosWithHttpInfo($query, $type, $cuisine, $diet, $include_ingredients, $exclude_ingredients, $min_length, $max_length, $offset, $number);
        return $response;
    }

    /**
     * Operation searchFoodVideosWithHttpInfo
     *
     * Search Food Videos
     *
     * @param  string $query The search query. (required)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  float $min_length Minimum video length in seconds. (optional)
     * @param  float $max_length Maximum video length in seconds. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchFoodVideosWithHttpInfo($query, $type = null, $cuisine = null, $diet = null, $include_ingredients = null, $exclude_ingredients = null, $min_length = null, $max_length = null, $offset = null, $number = null)
    {
        $request = $this->searchFoodVideosRequest($query, $type, $cuisine, $diet, $include_ingredients, $exclude_ingredients, $min_length, $max_length, $offset, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchFoodVideosAsync
     *
     * Search Food Videos
     *
     * @param  string $query The search query. (required)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  float $min_length Minimum video length in seconds. (optional)
     * @param  float $max_length Maximum video length in seconds. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchFoodVideosAsync($query, $type = null, $cuisine = null, $diet = null, $include_ingredients = null, $exclude_ingredients = null, $min_length = null, $max_length = null, $offset = null, $number = null)
    {
        return $this->searchFoodVideosAsyncWithHttpInfo($query, $type, $cuisine, $diet, $include_ingredients, $exclude_ingredients, $min_length, $max_length, $offset, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchFoodVideosAsyncWithHttpInfo
     *
     * Search Food Videos
     *
     * @param  string $query The search query. (required)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  float $min_length Minimum video length in seconds. (optional)
     * @param  float $max_length Maximum video length in seconds. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchFoodVideosAsyncWithHttpInfo($query, $type = null, $cuisine = null, $diet = null, $include_ingredients = null, $exclude_ingredients = null, $min_length = null, $max_length = null, $offset = null, $number = null)
    {
        $returnType = 'object';
        $request = $this->searchFoodVideosRequest($query, $type, $cuisine, $diet, $include_ingredients, $exclude_ingredients, $min_length, $max_length, $offset, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchFoodVideos'
     *
     * @param  string $query The search query. (required)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  float $min_length Minimum video length in seconds. (optional)
     * @param  float $max_length Maximum video length in seconds. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchFoodVideosRequest($query, $type = null, $cuisine = null, $diet = null, $include_ingredients = null, $exclude_ingredients = null, $min_length = null, $max_length = null, $offset = null, $number = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchFoodVideos'
            );
        }

        $resourcePath = '/food/videos/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($cuisine !== null) {
            $queryParams['cuisine'] = ObjectSerializer::toQueryValue($cuisine);
        }
        // query params
        if ($diet !== null) {
            $queryParams['diet'] = ObjectSerializer::toQueryValue($diet);
        }
        // query params
        if ($include_ingredients !== null) {
            $queryParams['includeIngredients'] = ObjectSerializer::toQueryValue($include_ingredients);
        }
        // query params
        if ($exclude_ingredients !== null) {
            $queryParams['excludeIngredients'] = ObjectSerializer::toQueryValue($exclude_ingredients);
        }
        // query params
        if ($min_length !== null) {
            $queryParams['minLength'] = ObjectSerializer::toQueryValue($min_length);
        }
        // query params
        if ($max_length !== null) {
            $queryParams['maxLength'] = ObjectSerializer::toQueryValue($max_length);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchGroceryProducts
     *
     * Search Grocery Products
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum amount of calories the product must have. (optional)
     * @param  float $max_calories The maximum amount of calories the product can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the product must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the product can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the product must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the product can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the product must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the product can have. (optional)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchGroceryProducts($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        list($response) = $this->searchGroceryProductsWithHttpInfo($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $offset, $number);
        return $response;
    }

    /**
     * Operation searchGroceryProductsWithHttpInfo
     *
     * Search Grocery Products
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum amount of calories the product must have. (optional)
     * @param  float $max_calories The maximum amount of calories the product can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the product must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the product can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the product must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the product can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the product must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the product can have. (optional)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchGroceryProductsWithHttpInfo($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        $request = $this->searchGroceryProductsRequest($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $offset, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchGroceryProductsAsync
     *
     * Search Grocery Products
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum amount of calories the product must have. (optional)
     * @param  float $max_calories The maximum amount of calories the product can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the product must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the product can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the product must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the product can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the product must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the product can have. (optional)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchGroceryProductsAsync($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        return $this->searchGroceryProductsAsyncWithHttpInfo($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $offset, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchGroceryProductsAsyncWithHttpInfo
     *
     * Search Grocery Products
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum amount of calories the product must have. (optional)
     * @param  float $max_calories The maximum amount of calories the product can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the product must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the product can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the product must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the product can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the product must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the product can have. (optional)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchGroceryProductsAsyncWithHttpInfo($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        $returnType = 'object';
        $request = $this->searchGroceryProductsRequest($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $offset, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchGroceryProducts'
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum amount of calories the product must have. (optional)
     * @param  float $max_calories The maximum amount of calories the product can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the product must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the product can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the product must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the product can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the product must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the product can have. (optional)
     * @param  float $offset The number of results to skip (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchGroceryProductsRequest($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchGroceryProducts'
            );
        }

        $resourcePath = '/food/products/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($min_calories !== null) {
            $queryParams['minCalories'] = ObjectSerializer::toQueryValue($min_calories);
        }
        // query params
        if ($max_calories !== null) {
            $queryParams['maxCalories'] = ObjectSerializer::toQueryValue($max_calories);
        }
        // query params
        if ($min_carbs !== null) {
            $queryParams['minCarbs'] = ObjectSerializer::toQueryValue($min_carbs);
        }
        // query params
        if ($max_carbs !== null) {
            $queryParams['maxCarbs'] = ObjectSerializer::toQueryValue($max_carbs);
        }
        // query params
        if ($min_protein !== null) {
            $queryParams['minProtein'] = ObjectSerializer::toQueryValue($min_protein);
        }
        // query params
        if ($max_protein !== null) {
            $queryParams['maxProtein'] = ObjectSerializer::toQueryValue($max_protein);
        }
        // query params
        if ($min_fat !== null) {
            $queryParams['minFat'] = ObjectSerializer::toQueryValue($min_fat);
        }
        // query params
        if ($max_fat !== null) {
            $queryParams['maxFat'] = ObjectSerializer::toQueryValue($max_fat);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchGroceryProductsByUPC
     *
     * Search Grocery Products by UPC
     *
     * @param  float $upc The product&#39;s UPC. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchGroceryProductsByUPC($upc)
    {
        list($response) = $this->searchGroceryProductsByUPCWithHttpInfo($upc);
        return $response;
    }

    /**
     * Operation searchGroceryProductsByUPCWithHttpInfo
     *
     * Search Grocery Products by UPC
     *
     * @param  float $upc The product&#39;s UPC. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchGroceryProductsByUPCWithHttpInfo($upc)
    {
        $request = $this->searchGroceryProductsByUPCRequest($upc);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchGroceryProductsByUPCAsync
     *
     * Search Grocery Products by UPC
     *
     * @param  float $upc The product&#39;s UPC. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchGroceryProductsByUPCAsync($upc)
    {
        return $this->searchGroceryProductsByUPCAsyncWithHttpInfo($upc)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchGroceryProductsByUPCAsyncWithHttpInfo
     *
     * Search Grocery Products by UPC
     *
     * @param  float $upc The product&#39;s UPC. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchGroceryProductsByUPCAsyncWithHttpInfo($upc)
    {
        $returnType = 'object';
        $request = $this->searchGroceryProductsByUPCRequest($upc);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchGroceryProductsByUPC'
     *
     * @param  float $upc The product&#39;s UPC. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchGroceryProductsByUPCRequest($upc)
    {
        // verify the required parameter 'upc' is set
        if ($upc === null || (is_array($upc) && count($upc) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $upc when calling searchGroceryProductsByUPC'
            );
        }

        $resourcePath = '/food/products/upc/{upc}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($upc !== null) {
            $resourcePath = str_replace(
                '{' . 'upc' . '}',
                ObjectSerializer::toPathValue($upc),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchMenuItems
     *
     * Search Menu Items
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum amount of calories the menu item must have. (optional)
     * @param  float $max_calories The maximum amount of calories the menu item can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the menu item must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the menu item can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the menu item must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the menu item can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the menu item must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the menu item can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 10). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchMenuItems($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        list($response) = $this->searchMenuItemsWithHttpInfo($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $offset, $number);
        return $response;
    }

    /**
     * Operation searchMenuItemsWithHttpInfo
     *
     * Search Menu Items
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum amount of calories the menu item must have. (optional)
     * @param  float $max_calories The maximum amount of calories the menu item can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the menu item must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the menu item can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the menu item must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the menu item can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the menu item must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the menu item can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 10). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchMenuItemsWithHttpInfo($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        $request = $this->searchMenuItemsRequest($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $offset, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchMenuItemsAsync
     *
     * Search Menu Items
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum amount of calories the menu item must have. (optional)
     * @param  float $max_calories The maximum amount of calories the menu item can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the menu item must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the menu item can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the menu item must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the menu item can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the menu item must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the menu item can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 10). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchMenuItemsAsync($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        return $this->searchMenuItemsAsyncWithHttpInfo($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $offset, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchMenuItemsAsyncWithHttpInfo
     *
     * Search Menu Items
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum amount of calories the menu item must have. (optional)
     * @param  float $max_calories The maximum amount of calories the menu item can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the menu item must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the menu item can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the menu item must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the menu item can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the menu item must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the menu item can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 10). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchMenuItemsAsyncWithHttpInfo($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        $returnType = 'object';
        $request = $this->searchMenuItemsRequest($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $offset, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchMenuItems'
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum amount of calories the menu item must have. (optional)
     * @param  float $max_calories The maximum amount of calories the menu item can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the menu item must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the menu item can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the menu item must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the menu item can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the menu item must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the menu item can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 10). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchMenuItemsRequest($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchMenuItems'
            );
        }

        $resourcePath = '/food/menuItems/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($min_calories !== null) {
            $queryParams['minCalories'] = ObjectSerializer::toQueryValue($min_calories);
        }
        // query params
        if ($max_calories !== null) {
            $queryParams['maxCalories'] = ObjectSerializer::toQueryValue($max_calories);
        }
        // query params
        if ($min_carbs !== null) {
            $queryParams['minCarbs'] = ObjectSerializer::toQueryValue($min_carbs);
        }
        // query params
        if ($max_carbs !== null) {
            $queryParams['maxCarbs'] = ObjectSerializer::toQueryValue($max_carbs);
        }
        // query params
        if ($min_protein !== null) {
            $queryParams['minProtein'] = ObjectSerializer::toQueryValue($min_protein);
        }
        // query params
        if ($max_protein !== null) {
            $queryParams['maxProtein'] = ObjectSerializer::toQueryValue($max_protein);
        }
        // query params
        if ($min_fat !== null) {
            $queryParams['minFat'] = ObjectSerializer::toQueryValue($min_fat);
        }
        // query params
        if ($max_fat !== null) {
            $queryParams['maxFat'] = ObjectSerializer::toQueryValue($max_fat);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchRecipes
     *
     * Search Recipes
     *
     * @param  string $query The (natural language) recipe search query. (required)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be used in the recipes. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  string $type The type of recipe. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the ingredients and whether they are used or missing in relation to the query. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. (optional)
     * @param  bool $add_recipe_nutrition If set to true, you get nutritional information about each recipes returned. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags User defined tags that have to match. The author param has to be set. (optional)
     * @param  float $recipe_box_id The id of the recipe box to which the search should be limited to. (optional)
     * @param  string $title_match Enter text that must be found in the title of the recipes. (optional)
     * @param  float $max_ready_time The maximum time in minutes it should take to prepare and cook the recipe. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchRecipes($query, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $add_recipe_nutrition = null, $author = null, $tags = null, $recipe_box_id = null, $title_match = null, $max_ready_time = null, $ignore_pantry = null, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $limit_license = null)
    {
        list($response) = $this->searchRecipesWithHttpInfo($query, $cuisine, $exclude_cuisine, $diet, $intolerances, $equipment, $include_ingredients, $exclude_ingredients, $type, $instructions_required, $fill_ingredients, $add_recipe_information, $add_recipe_nutrition, $author, $tags, $recipe_box_id, $title_match, $max_ready_time, $ignore_pantry, $sort, $sort_direction, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $limit_license);
        return $response;
    }

    /**
     * Operation searchRecipesWithHttpInfo
     *
     * Search Recipes
     *
     * @param  string $query The (natural language) recipe search query. (required)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be used in the recipes. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  string $type The type of recipe. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the ingredients and whether they are used or missing in relation to the query. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. (optional)
     * @param  bool $add_recipe_nutrition If set to true, you get nutritional information about each recipes returned. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags User defined tags that have to match. The author param has to be set. (optional)
     * @param  float $recipe_box_id The id of the recipe box to which the search should be limited to. (optional)
     * @param  string $title_match Enter text that must be found in the title of the recipes. (optional)
     * @param  float $max_ready_time The maximum time in minutes it should take to prepare and cook the recipe. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchRecipesWithHttpInfo($query, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $add_recipe_nutrition = null, $author = null, $tags = null, $recipe_box_id = null, $title_match = null, $max_ready_time = null, $ignore_pantry = null, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $limit_license = null)
    {
        $request = $this->searchRecipesRequest($query, $cuisine, $exclude_cuisine, $diet, $intolerances, $equipment, $include_ingredients, $exclude_ingredients, $type, $instructions_required, $fill_ingredients, $add_recipe_information, $add_recipe_nutrition, $author, $tags, $recipe_box_id, $title_match, $max_ready_time, $ignore_pantry, $sort, $sort_direction, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $limit_license);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchRecipesAsync
     *
     * Search Recipes
     *
     * @param  string $query The (natural language) recipe search query. (required)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be used in the recipes. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  string $type The type of recipe. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the ingredients and whether they are used or missing in relation to the query. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. (optional)
     * @param  bool $add_recipe_nutrition If set to true, you get nutritional information about each recipes returned. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags User defined tags that have to match. The author param has to be set. (optional)
     * @param  float $recipe_box_id The id of the recipe box to which the search should be limited to. (optional)
     * @param  string $title_match Enter text that must be found in the title of the recipes. (optional)
     * @param  float $max_ready_time The maximum time in minutes it should take to prepare and cook the recipe. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesAsync($query, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $add_recipe_nutrition = null, $author = null, $tags = null, $recipe_box_id = null, $title_match = null, $max_ready_time = null, $ignore_pantry = null, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $limit_license = null)
    {
        return $this->searchRecipesAsyncWithHttpInfo($query, $cuisine, $exclude_cuisine, $diet, $intolerances, $equipment, $include_ingredients, $exclude_ingredients, $type, $instructions_required, $fill_ingredients, $add_recipe_information, $add_recipe_nutrition, $author, $tags, $recipe_box_id, $title_match, $max_ready_time, $ignore_pantry, $sort, $sort_direction, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $limit_license)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchRecipesAsyncWithHttpInfo
     *
     * Search Recipes
     *
     * @param  string $query The (natural language) recipe search query. (required)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be used in the recipes. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  string $type The type of recipe. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the ingredients and whether they are used or missing in relation to the query. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. (optional)
     * @param  bool $add_recipe_nutrition If set to true, you get nutritional information about each recipes returned. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags User defined tags that have to match. The author param has to be set. (optional)
     * @param  float $recipe_box_id The id of the recipe box to which the search should be limited to. (optional)
     * @param  string $title_match Enter text that must be found in the title of the recipes. (optional)
     * @param  float $max_ready_time The maximum time in minutes it should take to prepare and cook the recipe. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesAsyncWithHttpInfo($query, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $add_recipe_nutrition = null, $author = null, $tags = null, $recipe_box_id = null, $title_match = null, $max_ready_time = null, $ignore_pantry = null, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $limit_license = null)
    {
        $returnType = 'object';
        $request = $this->searchRecipesRequest($query, $cuisine, $exclude_cuisine, $diet, $intolerances, $equipment, $include_ingredients, $exclude_ingredients, $type, $instructions_required, $fill_ingredients, $add_recipe_information, $add_recipe_nutrition, $author, $tags, $recipe_box_id, $title_match, $max_ready_time, $ignore_pantry, $sort, $sort_direction, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $limit_license);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchRecipes'
     *
     * @param  string $query The (natural language) recipe search query. (required)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be used in the recipes. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  string $type The type of recipe. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the ingredients and whether they are used or missing in relation to the query. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. (optional)
     * @param  bool $add_recipe_nutrition If set to true, you get nutritional information about each recipes returned. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags User defined tags that have to match. The author param has to be set. (optional)
     * @param  float $recipe_box_id The id of the recipe box to which the search should be limited to. (optional)
     * @param  string $title_match Enter text that must be found in the title of the recipes. (optional)
     * @param  float $max_ready_time The maximum time in minutes it should take to prepare and cook the recipe. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchRecipesRequest($query, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $add_recipe_nutrition = null, $author = null, $tags = null, $recipe_box_id = null, $title_match = null, $max_ready_time = null, $ignore_pantry = null, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $limit_license = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchRecipes'
            );
        }

        $resourcePath = '/recipes/complexSearch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($cuisine !== null) {
            $queryParams['cuisine'] = ObjectSerializer::toQueryValue($cuisine);
        }
        // query params
        if ($exclude_cuisine !== null) {
            $queryParams['excludeCuisine'] = ObjectSerializer::toQueryValue($exclude_cuisine);
        }
        // query params
        if ($diet !== null) {
            $queryParams['diet'] = ObjectSerializer::toQueryValue($diet);
        }
        // query params
        if ($intolerances !== null) {
            $queryParams['intolerances'] = ObjectSerializer::toQueryValue($intolerances);
        }
        // query params
        if ($equipment !== null) {
            $queryParams['equipment'] = ObjectSerializer::toQueryValue($equipment);
        }
        // query params
        if ($include_ingredients !== null) {
            $queryParams['includeIngredients'] = ObjectSerializer::toQueryValue($include_ingredients);
        }
        // query params
        if ($exclude_ingredients !== null) {
            $queryParams['excludeIngredients'] = ObjectSerializer::toQueryValue($exclude_ingredients);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($instructions_required !== null) {
            $queryParams['instructionsRequired'] = ObjectSerializer::toQueryValue($instructions_required);
        }
        // query params
        if ($fill_ingredients !== null) {
            $queryParams['fillIngredients'] = ObjectSerializer::toQueryValue($fill_ingredients);
        }
        // query params
        if ($add_recipe_information !== null) {
            $queryParams['addRecipeInformation'] = ObjectSerializer::toQueryValue($add_recipe_information);
        }
        // query params
        if ($add_recipe_nutrition !== null) {
            $queryParams['addRecipeNutrition'] = ObjectSerializer::toQueryValue($add_recipe_nutrition);
        }
        // query params
        if ($author !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($author);
        }
        // query params
        if ($tags !== null) {
            $queryParams['tags'] = ObjectSerializer::toQueryValue($tags);
        }
        // query params
        if ($recipe_box_id !== null) {
            $queryParams['recipeBoxId'] = ObjectSerializer::toQueryValue($recipe_box_id);
        }
        // query params
        if ($title_match !== null) {
            $queryParams['titleMatch'] = ObjectSerializer::toQueryValue($title_match);
        }
        // query params
        if ($max_ready_time !== null) {
            $queryParams['maxReadyTime'] = ObjectSerializer::toQueryValue($max_ready_time);
        }
        // query params
        if ($ignore_pantry !== null) {
            $queryParams['ignorePantry'] = ObjectSerializer::toQueryValue($ignore_pantry);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($sort_direction !== null) {
            $queryParams['sortDirection'] = ObjectSerializer::toQueryValue($sort_direction);
        }
        // query params
        if ($min_carbs !== null) {
            $queryParams['minCarbs'] = ObjectSerializer::toQueryValue($min_carbs);
        }
        // query params
        if ($max_carbs !== null) {
            $queryParams['maxCarbs'] = ObjectSerializer::toQueryValue($max_carbs);
        }
        // query params
        if ($min_protein !== null) {
            $queryParams['minProtein'] = ObjectSerializer::toQueryValue($min_protein);
        }
        // query params
        if ($max_protein !== null) {
            $queryParams['maxProtein'] = ObjectSerializer::toQueryValue($max_protein);
        }
        // query params
        if ($min_calories !== null) {
            $queryParams['minCalories'] = ObjectSerializer::toQueryValue($min_calories);
        }
        // query params
        if ($max_calories !== null) {
            $queryParams['maxCalories'] = ObjectSerializer::toQueryValue($max_calories);
        }
        // query params
        if ($min_fat !== null) {
            $queryParams['minFat'] = ObjectSerializer::toQueryValue($min_fat);
        }
        // query params
        if ($max_fat !== null) {
            $queryParams['maxFat'] = ObjectSerializer::toQueryValue($max_fat);
        }
        // query params
        if ($min_alcohol !== null) {
            $queryParams['minAlcohol'] = ObjectSerializer::toQueryValue($min_alcohol);
        }
        // query params
        if ($max_alcohol !== null) {
            $queryParams['maxAlcohol'] = ObjectSerializer::toQueryValue($max_alcohol);
        }
        // query params
        if ($min_caffeine !== null) {
            $queryParams['minCaffeine'] = ObjectSerializer::toQueryValue($min_caffeine);
        }
        // query params
        if ($max_caffeine !== null) {
            $queryParams['maxCaffeine'] = ObjectSerializer::toQueryValue($max_caffeine);
        }
        // query params
        if ($min_copper !== null) {
            $queryParams['minCopper'] = ObjectSerializer::toQueryValue($min_copper);
        }
        // query params
        if ($max_copper !== null) {
            $queryParams['maxCopper'] = ObjectSerializer::toQueryValue($max_copper);
        }
        // query params
        if ($min_calcium !== null) {
            $queryParams['minCalcium'] = ObjectSerializer::toQueryValue($min_calcium);
        }
        // query params
        if ($max_calcium !== null) {
            $queryParams['maxCalcium'] = ObjectSerializer::toQueryValue($max_calcium);
        }
        // query params
        if ($min_choline !== null) {
            $queryParams['minCholine'] = ObjectSerializer::toQueryValue($min_choline);
        }
        // query params
        if ($max_choline !== null) {
            $queryParams['maxCholine'] = ObjectSerializer::toQueryValue($max_choline);
        }
        // query params
        if ($min_cholesterol !== null) {
            $queryParams['minCholesterol'] = ObjectSerializer::toQueryValue($min_cholesterol);
        }
        // query params
        if ($max_cholesterol !== null) {
            $queryParams['maxCholesterol'] = ObjectSerializer::toQueryValue($max_cholesterol);
        }
        // query params
        if ($min_fluoride !== null) {
            $queryParams['minFluoride'] = ObjectSerializer::toQueryValue($min_fluoride);
        }
        // query params
        if ($max_fluoride !== null) {
            $queryParams['maxFluoride'] = ObjectSerializer::toQueryValue($max_fluoride);
        }
        // query params
        if ($min_saturated_fat !== null) {
            $queryParams['minSaturatedFat'] = ObjectSerializer::toQueryValue($min_saturated_fat);
        }
        // query params
        if ($max_saturated_fat !== null) {
            $queryParams['maxSaturatedFat'] = ObjectSerializer::toQueryValue($max_saturated_fat);
        }
        // query params
        if ($min_vitamin_a !== null) {
            $queryParams['minVitaminA'] = ObjectSerializer::toQueryValue($min_vitamin_a);
        }
        // query params
        if ($max_vitamin_a !== null) {
            $queryParams['maxVitaminA'] = ObjectSerializer::toQueryValue($max_vitamin_a);
        }
        // query params
        if ($min_vitamin_c !== null) {
            $queryParams['minVitaminC'] = ObjectSerializer::toQueryValue($min_vitamin_c);
        }
        // query params
        if ($max_vitamin_c !== null) {
            $queryParams['maxVitaminC'] = ObjectSerializer::toQueryValue($max_vitamin_c);
        }
        // query params
        if ($min_vitamin_d !== null) {
            $queryParams['minVitaminD'] = ObjectSerializer::toQueryValue($min_vitamin_d);
        }
        // query params
        if ($max_vitamin_d !== null) {
            $queryParams['maxVitaminD'] = ObjectSerializer::toQueryValue($max_vitamin_d);
        }
        // query params
        if ($min_vitamin_e !== null) {
            $queryParams['minVitaminE'] = ObjectSerializer::toQueryValue($min_vitamin_e);
        }
        // query params
        if ($max_vitamin_e !== null) {
            $queryParams['maxVitaminE'] = ObjectSerializer::toQueryValue($max_vitamin_e);
        }
        // query params
        if ($min_vitamin_k !== null) {
            $queryParams['minVitaminK'] = ObjectSerializer::toQueryValue($min_vitamin_k);
        }
        // query params
        if ($max_vitamin_k !== null) {
            $queryParams['maxVitaminK'] = ObjectSerializer::toQueryValue($max_vitamin_k);
        }
        // query params
        if ($min_vitamin_b1 !== null) {
            $queryParams['minVitaminB1'] = ObjectSerializer::toQueryValue($min_vitamin_b1);
        }
        // query params
        if ($max_vitamin_b1 !== null) {
            $queryParams['maxVitaminB1'] = ObjectSerializer::toQueryValue($max_vitamin_b1);
        }
        // query params
        if ($min_vitamin_b2 !== null) {
            $queryParams['minVitaminB2'] = ObjectSerializer::toQueryValue($min_vitamin_b2);
        }
        // query params
        if ($max_vitamin_b2 !== null) {
            $queryParams['maxVitaminB2'] = ObjectSerializer::toQueryValue($max_vitamin_b2);
        }
        // query params
        if ($min_vitamin_b5 !== null) {
            $queryParams['minVitaminB5'] = ObjectSerializer::toQueryValue($min_vitamin_b5);
        }
        // query params
        if ($max_vitamin_b5 !== null) {
            $queryParams['maxVitaminB5'] = ObjectSerializer::toQueryValue($max_vitamin_b5);
        }
        // query params
        if ($min_vitamin_b3 !== null) {
            $queryParams['minVitaminB3'] = ObjectSerializer::toQueryValue($min_vitamin_b3);
        }
        // query params
        if ($max_vitamin_b3 !== null) {
            $queryParams['maxVitaminB3'] = ObjectSerializer::toQueryValue($max_vitamin_b3);
        }
        // query params
        if ($min_vitamin_b6 !== null) {
            $queryParams['minVitaminB6'] = ObjectSerializer::toQueryValue($min_vitamin_b6);
        }
        // query params
        if ($max_vitamin_b6 !== null) {
            $queryParams['maxVitaminB6'] = ObjectSerializer::toQueryValue($max_vitamin_b6);
        }
        // query params
        if ($min_vitamin_b12 !== null) {
            $queryParams['minVitaminB12'] = ObjectSerializer::toQueryValue($min_vitamin_b12);
        }
        // query params
        if ($max_vitamin_b12 !== null) {
            $queryParams['maxVitaminB12'] = ObjectSerializer::toQueryValue($max_vitamin_b12);
        }
        // query params
        if ($min_fiber !== null) {
            $queryParams['minFiber'] = ObjectSerializer::toQueryValue($min_fiber);
        }
        // query params
        if ($max_fiber !== null) {
            $queryParams['maxFiber'] = ObjectSerializer::toQueryValue($max_fiber);
        }
        // query params
        if ($min_folate !== null) {
            $queryParams['minFolate'] = ObjectSerializer::toQueryValue($min_folate);
        }
        // query params
        if ($max_folate !== null) {
            $queryParams['maxFolate'] = ObjectSerializer::toQueryValue($max_folate);
        }
        // query params
        if ($min_folic_acid !== null) {
            $queryParams['minFolicAcid'] = ObjectSerializer::toQueryValue($min_folic_acid);
        }
        // query params
        if ($max_folic_acid !== null) {
            $queryParams['maxFolicAcid'] = ObjectSerializer::toQueryValue($max_folic_acid);
        }
        // query params
        if ($min_iodine !== null) {
            $queryParams['minIodine'] = ObjectSerializer::toQueryValue($min_iodine);
        }
        // query params
        if ($max_iodine !== null) {
            $queryParams['maxIodine'] = ObjectSerializer::toQueryValue($max_iodine);
        }
        // query params
        if ($min_iron !== null) {
            $queryParams['minIron'] = ObjectSerializer::toQueryValue($min_iron);
        }
        // query params
        if ($max_iron !== null) {
            $queryParams['maxIron'] = ObjectSerializer::toQueryValue($max_iron);
        }
        // query params
        if ($min_magnesium !== null) {
            $queryParams['minMagnesium'] = ObjectSerializer::toQueryValue($min_magnesium);
        }
        // query params
        if ($max_magnesium !== null) {
            $queryParams['maxMagnesium'] = ObjectSerializer::toQueryValue($max_magnesium);
        }
        // query params
        if ($min_manganese !== null) {
            $queryParams['minManganese'] = ObjectSerializer::toQueryValue($min_manganese);
        }
        // query params
        if ($max_manganese !== null) {
            $queryParams['maxManganese'] = ObjectSerializer::toQueryValue($max_manganese);
        }
        // query params
        if ($min_phosphorus !== null) {
            $queryParams['minPhosphorus'] = ObjectSerializer::toQueryValue($min_phosphorus);
        }
        // query params
        if ($max_phosphorus !== null) {
            $queryParams['maxPhosphorus'] = ObjectSerializer::toQueryValue($max_phosphorus);
        }
        // query params
        if ($min_potassium !== null) {
            $queryParams['minPotassium'] = ObjectSerializer::toQueryValue($min_potassium);
        }
        // query params
        if ($max_potassium !== null) {
            $queryParams['maxPotassium'] = ObjectSerializer::toQueryValue($max_potassium);
        }
        // query params
        if ($min_selenium !== null) {
            $queryParams['minSelenium'] = ObjectSerializer::toQueryValue($min_selenium);
        }
        // query params
        if ($max_selenium !== null) {
            $queryParams['maxSelenium'] = ObjectSerializer::toQueryValue($max_selenium);
        }
        // query params
        if ($min_sodium !== null) {
            $queryParams['minSodium'] = ObjectSerializer::toQueryValue($min_sodium);
        }
        // query params
        if ($max_sodium !== null) {
            $queryParams['maxSodium'] = ObjectSerializer::toQueryValue($max_sodium);
        }
        // query params
        if ($min_sugar !== null) {
            $queryParams['minSugar'] = ObjectSerializer::toQueryValue($min_sugar);
        }
        // query params
        if ($max_sugar !== null) {
            $queryParams['maxSugar'] = ObjectSerializer::toQueryValue($max_sugar);
        }
        // query params
        if ($min_zinc !== null) {
            $queryParams['minZinc'] = ObjectSerializer::toQueryValue($min_zinc);
        }
        // query params
        if ($max_zinc !== null) {
            $queryParams['maxZinc'] = ObjectSerializer::toQueryValue($max_zinc);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }
        // query params
        if ($limit_license !== null) {
            $queryParams['limitLicense'] = ObjectSerializer::toQueryValue($limit_license);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchRecipesByIngredients
     *
     * Search Recipes by Ingredients
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (required)
     * @param  float $number The maximum number of recipes to return (between 1 and 100). Defaults to 10. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchRecipesByIngredients($ingredients, $number = null, $limit_license = null, $ranking = null, $ignore_pantry = null)
    {
        list($response) = $this->searchRecipesByIngredientsWithHttpInfo($ingredients, $number, $limit_license, $ranking, $ignore_pantry);
        return $response;
    }

    /**
     * Operation searchRecipesByIngredientsWithHttpInfo
     *
     * Search Recipes by Ingredients
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (required)
     * @param  float $number The maximum number of recipes to return (between 1 and 100). Defaults to 10. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchRecipesByIngredientsWithHttpInfo($ingredients, $number = null, $limit_license = null, $ranking = null, $ignore_pantry = null)
    {
        $request = $this->searchRecipesByIngredientsRequest($ingredients, $number, $limit_license, $ranking, $ignore_pantry);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchRecipesByIngredientsAsync
     *
     * Search Recipes by Ingredients
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (required)
     * @param  float $number The maximum number of recipes to return (between 1 and 100). Defaults to 10. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesByIngredientsAsync($ingredients, $number = null, $limit_license = null, $ranking = null, $ignore_pantry = null)
    {
        return $this->searchRecipesByIngredientsAsyncWithHttpInfo($ingredients, $number, $limit_license, $ranking, $ignore_pantry)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchRecipesByIngredientsAsyncWithHttpInfo
     *
     * Search Recipes by Ingredients
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (required)
     * @param  float $number The maximum number of recipes to return (between 1 and 100). Defaults to 10. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesByIngredientsAsyncWithHttpInfo($ingredients, $number = null, $limit_license = null, $ranking = null, $ignore_pantry = null)
    {
        $returnType = 'object';
        $request = $this->searchRecipesByIngredientsRequest($ingredients, $number, $limit_license, $ranking, $ignore_pantry);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchRecipesByIngredients'
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (required)
     * @param  float $number The maximum number of recipes to return (between 1 and 100). Defaults to 10. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchRecipesByIngredientsRequest($ingredients, $number = null, $limit_license = null, $ranking = null, $ignore_pantry = null)
    {
        // verify the required parameter 'ingredients' is set
        if ($ingredients === null || (is_array($ingredients) && count($ingredients) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredients when calling searchRecipesByIngredients'
            );
        }

        $resourcePath = '/recipes/findByIngredients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ingredients !== null) {
            $queryParams['ingredients'] = ObjectSerializer::toQueryValue($ingredients);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }
        // query params
        if ($limit_license !== null) {
            $queryParams['limitLicense'] = ObjectSerializer::toQueryValue($limit_license);
        }
        // query params
        if ($ranking !== null) {
            $queryParams['ranking'] = ObjectSerializer::toQueryValue($ranking);
        }
        // query params
        if ($ignore_pantry !== null) {
            $queryParams['ignorePantry'] = ObjectSerializer::toQueryValue($ignore_pantry);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchRecipesByNutrients
     *
     * Search Recipes by Nutrients
     *
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchRecipesByNutrients($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $random = null, $limit_license = null)
    {
        list($response) = $this->searchRecipesByNutrientsWithHttpInfo($min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $random, $limit_license);
        return $response;
    }

    /**
     * Operation searchRecipesByNutrientsWithHttpInfo
     *
     * Search Recipes by Nutrients
     *
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchRecipesByNutrientsWithHttpInfo($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $random = null, $limit_license = null)
    {
        $request = $this->searchRecipesByNutrientsRequest($min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $random, $limit_license);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchRecipesByNutrientsAsync
     *
     * Search Recipes by Nutrients
     *
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesByNutrientsAsync($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $random = null, $limit_license = null)
    {
        return $this->searchRecipesByNutrientsAsyncWithHttpInfo($min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $random, $limit_license)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchRecipesByNutrientsAsyncWithHttpInfo
     *
     * Search Recipes by Nutrients
     *
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesByNutrientsAsyncWithHttpInfo($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $random = null, $limit_license = null)
    {
        $returnType = 'object';
        $request = $this->searchRecipesByNutrientsRequest($min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $random, $limit_license);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchRecipesByNutrients'
     *
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchRecipesByNutrientsRequest($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $random = null, $limit_license = null)
    {

        $resourcePath = '/recipes/findByNutrients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($min_carbs !== null) {
            $queryParams['minCarbs'] = ObjectSerializer::toQueryValue($min_carbs);
        }
        // query params
        if ($max_carbs !== null) {
            $queryParams['maxCarbs'] = ObjectSerializer::toQueryValue($max_carbs);
        }
        // query params
        if ($min_protein !== null) {
            $queryParams['minProtein'] = ObjectSerializer::toQueryValue($min_protein);
        }
        // query params
        if ($max_protein !== null) {
            $queryParams['maxProtein'] = ObjectSerializer::toQueryValue($max_protein);
        }
        // query params
        if ($min_calories !== null) {
            $queryParams['minCalories'] = ObjectSerializer::toQueryValue($min_calories);
        }
        // query params
        if ($max_calories !== null) {
            $queryParams['maxCalories'] = ObjectSerializer::toQueryValue($max_calories);
        }
        // query params
        if ($min_fat !== null) {
            $queryParams['minFat'] = ObjectSerializer::toQueryValue($min_fat);
        }
        // query params
        if ($max_fat !== null) {
            $queryParams['maxFat'] = ObjectSerializer::toQueryValue($max_fat);
        }
        // query params
        if ($min_alcohol !== null) {
            $queryParams['minAlcohol'] = ObjectSerializer::toQueryValue($min_alcohol);
        }
        // query params
        if ($max_alcohol !== null) {
            $queryParams['maxAlcohol'] = ObjectSerializer::toQueryValue($max_alcohol);
        }
        // query params
        if ($min_caffeine !== null) {
            $queryParams['minCaffeine'] = ObjectSerializer::toQueryValue($min_caffeine);
        }
        // query params
        if ($max_caffeine !== null) {
            $queryParams['maxCaffeine'] = ObjectSerializer::toQueryValue($max_caffeine);
        }
        // query params
        if ($min_copper !== null) {
            $queryParams['minCopper'] = ObjectSerializer::toQueryValue($min_copper);
        }
        // query params
        if ($max_copper !== null) {
            $queryParams['maxCopper'] = ObjectSerializer::toQueryValue($max_copper);
        }
        // query params
        if ($min_calcium !== null) {
            $queryParams['minCalcium'] = ObjectSerializer::toQueryValue($min_calcium);
        }
        // query params
        if ($max_calcium !== null) {
            $queryParams['maxCalcium'] = ObjectSerializer::toQueryValue($max_calcium);
        }
        // query params
        if ($min_choline !== null) {
            $queryParams['minCholine'] = ObjectSerializer::toQueryValue($min_choline);
        }
        // query params
        if ($max_choline !== null) {
            $queryParams['maxCholine'] = ObjectSerializer::toQueryValue($max_choline);
        }
        // query params
        if ($min_cholesterol !== null) {
            $queryParams['minCholesterol'] = ObjectSerializer::toQueryValue($min_cholesterol);
        }
        // query params
        if ($max_cholesterol !== null) {
            $queryParams['maxCholesterol'] = ObjectSerializer::toQueryValue($max_cholesterol);
        }
        // query params
        if ($min_fluoride !== null) {
            $queryParams['minFluoride'] = ObjectSerializer::toQueryValue($min_fluoride);
        }
        // query params
        if ($max_fluoride !== null) {
            $queryParams['maxFluoride'] = ObjectSerializer::toQueryValue($max_fluoride);
        }
        // query params
        if ($min_saturated_fat !== null) {
            $queryParams['minSaturatedFat'] = ObjectSerializer::toQueryValue($min_saturated_fat);
        }
        // query params
        if ($max_saturated_fat !== null) {
            $queryParams['maxSaturatedFat'] = ObjectSerializer::toQueryValue($max_saturated_fat);
        }
        // query params
        if ($min_vitamin_a !== null) {
            $queryParams['minVitaminA'] = ObjectSerializer::toQueryValue($min_vitamin_a);
        }
        // query params
        if ($max_vitamin_a !== null) {
            $queryParams['maxVitaminA'] = ObjectSerializer::toQueryValue($max_vitamin_a);
        }
        // query params
        if ($min_vitamin_c !== null) {
            $queryParams['minVitaminC'] = ObjectSerializer::toQueryValue($min_vitamin_c);
        }
        // query params
        if ($max_vitamin_c !== null) {
            $queryParams['maxVitaminC'] = ObjectSerializer::toQueryValue($max_vitamin_c);
        }
        // query params
        if ($min_vitamin_d !== null) {
            $queryParams['minVitaminD'] = ObjectSerializer::toQueryValue($min_vitamin_d);
        }
        // query params
        if ($max_vitamin_d !== null) {
            $queryParams['maxVitaminD'] = ObjectSerializer::toQueryValue($max_vitamin_d);
        }
        // query params
        if ($min_vitamin_e !== null) {
            $queryParams['minVitaminE'] = ObjectSerializer::toQueryValue($min_vitamin_e);
        }
        // query params
        if ($max_vitamin_e !== null) {
            $queryParams['maxVitaminE'] = ObjectSerializer::toQueryValue($max_vitamin_e);
        }
        // query params
        if ($min_vitamin_k !== null) {
            $queryParams['minVitaminK'] = ObjectSerializer::toQueryValue($min_vitamin_k);
        }
        // query params
        if ($max_vitamin_k !== null) {
            $queryParams['maxVitaminK'] = ObjectSerializer::toQueryValue($max_vitamin_k);
        }
        // query params
        if ($min_vitamin_b1 !== null) {
            $queryParams['minVitaminB1'] = ObjectSerializer::toQueryValue($min_vitamin_b1);
        }
        // query params
        if ($max_vitamin_b1 !== null) {
            $queryParams['maxVitaminB1'] = ObjectSerializer::toQueryValue($max_vitamin_b1);
        }
        // query params
        if ($min_vitamin_b2 !== null) {
            $queryParams['minVitaminB2'] = ObjectSerializer::toQueryValue($min_vitamin_b2);
        }
        // query params
        if ($max_vitamin_b2 !== null) {
            $queryParams['maxVitaminB2'] = ObjectSerializer::toQueryValue($max_vitamin_b2);
        }
        // query params
        if ($min_vitamin_b5 !== null) {
            $queryParams['minVitaminB5'] = ObjectSerializer::toQueryValue($min_vitamin_b5);
        }
        // query params
        if ($max_vitamin_b5 !== null) {
            $queryParams['maxVitaminB5'] = ObjectSerializer::toQueryValue($max_vitamin_b5);
        }
        // query params
        if ($min_vitamin_b3 !== null) {
            $queryParams['minVitaminB3'] = ObjectSerializer::toQueryValue($min_vitamin_b3);
        }
        // query params
        if ($max_vitamin_b3 !== null) {
            $queryParams['maxVitaminB3'] = ObjectSerializer::toQueryValue($max_vitamin_b3);
        }
        // query params
        if ($min_vitamin_b6 !== null) {
            $queryParams['minVitaminB6'] = ObjectSerializer::toQueryValue($min_vitamin_b6);
        }
        // query params
        if ($max_vitamin_b6 !== null) {
            $queryParams['maxVitaminB6'] = ObjectSerializer::toQueryValue($max_vitamin_b6);
        }
        // query params
        if ($min_vitamin_b12 !== null) {
            $queryParams['minVitaminB12'] = ObjectSerializer::toQueryValue($min_vitamin_b12);
        }
        // query params
        if ($max_vitamin_b12 !== null) {
            $queryParams['maxVitaminB12'] = ObjectSerializer::toQueryValue($max_vitamin_b12);
        }
        // query params
        if ($min_fiber !== null) {
            $queryParams['minFiber'] = ObjectSerializer::toQueryValue($min_fiber);
        }
        // query params
        if ($max_fiber !== null) {
            $queryParams['maxFiber'] = ObjectSerializer::toQueryValue($max_fiber);
        }
        // query params
        if ($min_folate !== null) {
            $queryParams['minFolate'] = ObjectSerializer::toQueryValue($min_folate);
        }
        // query params
        if ($max_folate !== null) {
            $queryParams['maxFolate'] = ObjectSerializer::toQueryValue($max_folate);
        }
        // query params
        if ($min_folic_acid !== null) {
            $queryParams['minFolicAcid'] = ObjectSerializer::toQueryValue($min_folic_acid);
        }
        // query params
        if ($max_folic_acid !== null) {
            $queryParams['maxFolicAcid'] = ObjectSerializer::toQueryValue($max_folic_acid);
        }
        // query params
        if ($min_iodine !== null) {
            $queryParams['minIodine'] = ObjectSerializer::toQueryValue($min_iodine);
        }
        // query params
        if ($max_iodine !== null) {
            $queryParams['maxIodine'] = ObjectSerializer::toQueryValue($max_iodine);
        }
        // query params
        if ($min_iron !== null) {
            $queryParams['minIron'] = ObjectSerializer::toQueryValue($min_iron);
        }
        // query params
        if ($max_iron !== null) {
            $queryParams['maxIron'] = ObjectSerializer::toQueryValue($max_iron);
        }
        // query params
        if ($min_magnesium !== null) {
            $queryParams['minMagnesium'] = ObjectSerializer::toQueryValue($min_magnesium);
        }
        // query params
        if ($max_magnesium !== null) {
            $queryParams['maxMagnesium'] = ObjectSerializer::toQueryValue($max_magnesium);
        }
        // query params
        if ($min_manganese !== null) {
            $queryParams['minManganese'] = ObjectSerializer::toQueryValue($min_manganese);
        }
        // query params
        if ($max_manganese !== null) {
            $queryParams['maxManganese'] = ObjectSerializer::toQueryValue($max_manganese);
        }
        // query params
        if ($min_phosphorus !== null) {
            $queryParams['minPhosphorus'] = ObjectSerializer::toQueryValue($min_phosphorus);
        }
        // query params
        if ($max_phosphorus !== null) {
            $queryParams['maxPhosphorus'] = ObjectSerializer::toQueryValue($max_phosphorus);
        }
        // query params
        if ($min_potassium !== null) {
            $queryParams['minPotassium'] = ObjectSerializer::toQueryValue($min_potassium);
        }
        // query params
        if ($max_potassium !== null) {
            $queryParams['maxPotassium'] = ObjectSerializer::toQueryValue($max_potassium);
        }
        // query params
        if ($min_selenium !== null) {
            $queryParams['minSelenium'] = ObjectSerializer::toQueryValue($min_selenium);
        }
        // query params
        if ($max_selenium !== null) {
            $queryParams['maxSelenium'] = ObjectSerializer::toQueryValue($max_selenium);
        }
        // query params
        if ($min_sodium !== null) {
            $queryParams['minSodium'] = ObjectSerializer::toQueryValue($min_sodium);
        }
        // query params
        if ($max_sodium !== null) {
            $queryParams['maxSodium'] = ObjectSerializer::toQueryValue($max_sodium);
        }
        // query params
        if ($min_sugar !== null) {
            $queryParams['minSugar'] = ObjectSerializer::toQueryValue($min_sugar);
        }
        // query params
        if ($max_sugar !== null) {
            $queryParams['maxSugar'] = ObjectSerializer::toQueryValue($max_sugar);
        }
        // query params
        if ($min_zinc !== null) {
            $queryParams['minZinc'] = ObjectSerializer::toQueryValue($min_zinc);
        }
        // query params
        if ($max_zinc !== null) {
            $queryParams['maxZinc'] = ObjectSerializer::toQueryValue($max_zinc);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }
        // query params
        if ($random !== null) {
            $queryParams['random'] = ObjectSerializer::toQueryValue($random);
        }
        // query params
        if ($limit_license !== null) {
            $queryParams['limitLicense'] = ObjectSerializer::toQueryValue($limit_license);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchSiteContent
     *
     * Search Site Content
     *
     * @param  string $query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchSiteContent($query)
    {
        list($response) = $this->searchSiteContentWithHttpInfo($query);
        return $response;
    }

    /**
     * Operation searchSiteContentWithHttpInfo
     *
     * Search Site Content
     *
     * @param  string $query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchSiteContentWithHttpInfo($query)
    {
        $request = $this->searchSiteContentRequest($query);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchSiteContentAsync
     *
     * Search Site Content
     *
     * @param  string $query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchSiteContentAsync($query)
    {
        return $this->searchSiteContentAsyncWithHttpInfo($query)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchSiteContentAsyncWithHttpInfo
     *
     * Search Site Content
     *
     * @param  string $query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchSiteContentAsyncWithHttpInfo($query)
    {
        $returnType = 'object';
        $request = $this->searchSiteContentRequest($query);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchSiteContent'
     *
     * @param  string $query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchSiteContentRequest($query)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchSiteContent'
            );
        }

        $resourcePath = '/food/site/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation summarizeRecipe
     *
     * Summarize Recipe
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function summarizeRecipe($id)
    {
        list($response) = $this->summarizeRecipeWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation summarizeRecipeWithHttpInfo
     *
     * Summarize Recipe
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function summarizeRecipeWithHttpInfo($id)
    {
        $request = $this->summarizeRecipeRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation summarizeRecipeAsync
     *
     * Summarize Recipe
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function summarizeRecipeAsync($id)
    {
        return $this->summarizeRecipeAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation summarizeRecipeAsyncWithHttpInfo
     *
     * Summarize Recipe
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function summarizeRecipeAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->summarizeRecipeRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'summarizeRecipe'
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function summarizeRecipeRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling summarizeRecipe'
            );
        }

        $resourcePath = '/recipes/{id}/summary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation talkToChatbot
     *
     * Talk to Chatbot
     *
     * @param  string $text The request / question / answer from the user to the chatbot. (required)
     * @param  string $context_id An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function talkToChatbot($text, $context_id = null)
    {
        list($response) = $this->talkToChatbotWithHttpInfo($text, $context_id);
        return $response;
    }

    /**
     * Operation talkToChatbotWithHttpInfo
     *
     * Talk to Chatbot
     *
     * @param  string $text The request / question / answer from the user to the chatbot. (required)
     * @param  string $context_id An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function talkToChatbotWithHttpInfo($text, $context_id = null)
    {
        $request = $this->talkToChatbotRequest($text, $context_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation talkToChatbotAsync
     *
     * Talk to Chatbot
     *
     * @param  string $text The request / question / answer from the user to the chatbot. (required)
     * @param  string $context_id An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function talkToChatbotAsync($text, $context_id = null)
    {
        return $this->talkToChatbotAsyncWithHttpInfo($text, $context_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation talkToChatbotAsyncWithHttpInfo
     *
     * Talk to Chatbot
     *
     * @param  string $text The request / question / answer from the user to the chatbot. (required)
     * @param  string $context_id An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function talkToChatbotAsyncWithHttpInfo($text, $context_id = null)
    {
        $returnType = 'object';
        $request = $this->talkToChatbotRequest($text, $context_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'talkToChatbot'
     *
     * @param  string $text The request / question / answer from the user to the chatbot. (required)
     * @param  string $context_id An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function talkToChatbotRequest($text, $context_id = null)
    {
        // verify the required parameter 'text' is set
        if ($text === null || (is_array($text) && count($text) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text when calling talkToChatbot'
            );
        }

        $resourcePath = '/food/converse';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($text !== null) {
            $queryParams['text'] = ObjectSerializer::toQueryValue($text);
        }
        // query params
        if ($context_id !== null) {
            $queryParams['contextId'] = ObjectSerializer::toQueryValue($context_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeEquipment
     *
     * Visualize Equipment
     *
     * @param  string $instructions The recipe&#39;s instructions. (required)
     * @param  string $view How to visualize the equipment, either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeEquipment($instructions, $view = null, $default_css = null, $show_backlink = null)
    {
        list($response) = $this->visualizeEquipmentWithHttpInfo($instructions, $view, $default_css, $show_backlink);
        return $response;
    }

    /**
     * Operation visualizeEquipmentWithHttpInfo
     *
     * Visualize Equipment
     *
     * @param  string $instructions The recipe&#39;s instructions. (required)
     * @param  string $view How to visualize the equipment, either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeEquipmentWithHttpInfo($instructions, $view = null, $default_css = null, $show_backlink = null)
    {
        $request = $this->visualizeEquipmentRequest($instructions, $view, $default_css, $show_backlink);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeEquipmentAsync
     *
     * Visualize Equipment
     *
     * @param  string $instructions The recipe&#39;s instructions. (required)
     * @param  string $view How to visualize the equipment, either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeEquipmentAsync($instructions, $view = null, $default_css = null, $show_backlink = null)
    {
        return $this->visualizeEquipmentAsyncWithHttpInfo($instructions, $view, $default_css, $show_backlink)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeEquipmentAsyncWithHttpInfo
     *
     * Visualize Equipment
     *
     * @param  string $instructions The recipe&#39;s instructions. (required)
     * @param  string $view How to visualize the equipment, either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeEquipmentAsyncWithHttpInfo($instructions, $view = null, $default_css = null, $show_backlink = null)
    {
        $returnType = 'string';
        $request = $this->visualizeEquipmentRequest($instructions, $view, $default_css, $show_backlink);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeEquipment'
     *
     * @param  string $instructions The recipe&#39;s instructions. (required)
     * @param  string $view How to visualize the equipment, either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeEquipmentRequest($instructions, $view = null, $default_css = null, $show_backlink = null)
    {
        // verify the required parameter 'instructions' is set
        if ($instructions === null || (is_array($instructions) && count($instructions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instructions when calling visualizeEquipment'
            );
        }

        $resourcePath = '/recipes/visualizeEquipment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($instructions !== null) {
            $formParams['instructions'] = ObjectSerializer::toFormValue($instructions);
        }
        // form params
        if ($view !== null) {
            $formParams['view'] = ObjectSerializer::toFormValue($view);
        }
        // form params
        if ($default_css !== null) {
            $formParams['defaultCss'] = ObjectSerializer::toFormValue($default_css);
        }
        // form params
        if ($show_backlink !== null) {
            $formParams['showBacklink'] = ObjectSerializer::toFormValue($show_backlink);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeIngredients
     *
     * Visualize Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $measure The original system of measurement, either \\\&quot;metric\\\&quot; or \\\&quot;us\\\&quot;. (optional)
     * @param  string $view How to visualize the ingredients, either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeIngredients($ingredient_list, $servings, $measure = null, $view = null, $default_css = null, $show_backlink = null)
    {
        list($response) = $this->visualizeIngredientsWithHttpInfo($ingredient_list, $servings, $measure, $view, $default_css, $show_backlink);
        return $response;
    }

    /**
     * Operation visualizeIngredientsWithHttpInfo
     *
     * Visualize Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $measure The original system of measurement, either \\\&quot;metric\\\&quot; or \\\&quot;us\\\&quot;. (optional)
     * @param  string $view How to visualize the ingredients, either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeIngredientsWithHttpInfo($ingredient_list, $servings, $measure = null, $view = null, $default_css = null, $show_backlink = null)
    {
        $request = $this->visualizeIngredientsRequest($ingredient_list, $servings, $measure, $view, $default_css, $show_backlink);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeIngredientsAsync
     *
     * Visualize Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $measure The original system of measurement, either \\\&quot;metric\\\&quot; or \\\&quot;us\\\&quot;. (optional)
     * @param  string $view How to visualize the ingredients, either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeIngredientsAsync($ingredient_list, $servings, $measure = null, $view = null, $default_css = null, $show_backlink = null)
    {
        return $this->visualizeIngredientsAsyncWithHttpInfo($ingredient_list, $servings, $measure, $view, $default_css, $show_backlink)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeIngredientsAsyncWithHttpInfo
     *
     * Visualize Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $measure The original system of measurement, either \\\&quot;metric\\\&quot; or \\\&quot;us\\\&quot;. (optional)
     * @param  string $view How to visualize the ingredients, either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeIngredientsAsyncWithHttpInfo($ingredient_list, $servings, $measure = null, $view = null, $default_css = null, $show_backlink = null)
    {
        $returnType = 'string';
        $request = $this->visualizeIngredientsRequest($ingredient_list, $servings, $measure, $view, $default_css, $show_backlink);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeIngredients'
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $measure The original system of measurement, either \\\&quot;metric\\\&quot; or \\\&quot;us\\\&quot;. (optional)
     * @param  string $view How to visualize the ingredients, either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeIngredientsRequest($ingredient_list, $servings, $measure = null, $view = null, $default_css = null, $show_backlink = null)
    {
        // verify the required parameter 'ingredient_list' is set
        if ($ingredient_list === null || (is_array($ingredient_list) && count($ingredient_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_list when calling visualizeIngredients'
            );
        }
        // verify the required parameter 'servings' is set
        if ($servings === null || (is_array($servings) && count($servings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $servings when calling visualizeIngredients'
            );
        }

        $resourcePath = '/recipes/visualizeIngredients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($ingredient_list !== null) {
            $formParams['ingredientList'] = ObjectSerializer::toFormValue($ingredient_list);
        }
        // form params
        if ($servings !== null) {
            $formParams['servings'] = ObjectSerializer::toFormValue($servings);
        }
        // form params
        if ($measure !== null) {
            $formParams['measure'] = ObjectSerializer::toFormValue($measure);
        }
        // form params
        if ($view !== null) {
            $formParams['view'] = ObjectSerializer::toFormValue($view);
        }
        // form params
        if ($default_css !== null) {
            $formParams['defaultCss'] = ObjectSerializer::toFormValue($default_css);
        }
        // form params
        if ($show_backlink !== null) {
            $formParams['showBacklink'] = ObjectSerializer::toFormValue($show_backlink);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeMenuItemNutritionByID
     *
     * Visualize Menu Item Nutrition by ID
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeMenuItemNutritionByID($id, $default_css = null)
    {
        list($response) = $this->visualizeMenuItemNutritionByIDWithHttpInfo($id, $default_css);
        return $response;
    }

    /**
     * Operation visualizeMenuItemNutritionByIDWithHttpInfo
     *
     * Visualize Menu Item Nutrition by ID
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeMenuItemNutritionByIDWithHttpInfo($id, $default_css = null)
    {
        $request = $this->visualizeMenuItemNutritionByIDRequest($id, $default_css);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeMenuItemNutritionByIDAsync
     *
     * Visualize Menu Item Nutrition by ID
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeMenuItemNutritionByIDAsync($id, $default_css = null)
    {
        return $this->visualizeMenuItemNutritionByIDAsyncWithHttpInfo($id, $default_css)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeMenuItemNutritionByIDAsyncWithHttpInfo
     *
     * Visualize Menu Item Nutrition by ID
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeMenuItemNutritionByIDAsyncWithHttpInfo($id, $default_css = null)
    {
        $returnType = 'string';
        $request = $this->visualizeMenuItemNutritionByIDRequest($id, $default_css);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeMenuItemNutritionByID'
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeMenuItemNutritionByIDRequest($id, $default_css = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeMenuItemNutritionByID'
            );
        }

        $resourcePath = '/food/menuItems/{id}/nutritionWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_css !== null) {
            $queryParams['defaultCss'] = ObjectSerializer::toQueryValue($default_css);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizePriceBreakdown
     *
     * Visualize Price Breakdown
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  float $mode The mode in which the widget should be delivered. 1 &#x3D; separate views (compact), 2 &#x3D; all in one view (full). (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizePriceBreakdown($ingredient_list, $servings, $mode = null, $default_css = null, $show_backlink = null)
    {
        list($response) = $this->visualizePriceBreakdownWithHttpInfo($ingredient_list, $servings, $mode, $default_css, $show_backlink);
        return $response;
    }

    /**
     * Operation visualizePriceBreakdownWithHttpInfo
     *
     * Visualize Price Breakdown
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  float $mode The mode in which the widget should be delivered. 1 &#x3D; separate views (compact), 2 &#x3D; all in one view (full). (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizePriceBreakdownWithHttpInfo($ingredient_list, $servings, $mode = null, $default_css = null, $show_backlink = null)
    {
        $request = $this->visualizePriceBreakdownRequest($ingredient_list, $servings, $mode, $default_css, $show_backlink);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizePriceBreakdownAsync
     *
     * Visualize Price Breakdown
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  float $mode The mode in which the widget should be delivered. 1 &#x3D; separate views (compact), 2 &#x3D; all in one view (full). (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizePriceBreakdownAsync($ingredient_list, $servings, $mode = null, $default_css = null, $show_backlink = null)
    {
        return $this->visualizePriceBreakdownAsyncWithHttpInfo($ingredient_list, $servings, $mode, $default_css, $show_backlink)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizePriceBreakdownAsyncWithHttpInfo
     *
     * Visualize Price Breakdown
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  float $mode The mode in which the widget should be delivered. 1 &#x3D; separate views (compact), 2 &#x3D; all in one view (full). (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizePriceBreakdownAsyncWithHttpInfo($ingredient_list, $servings, $mode = null, $default_css = null, $show_backlink = null)
    {
        $returnType = 'string';
        $request = $this->visualizePriceBreakdownRequest($ingredient_list, $servings, $mode, $default_css, $show_backlink);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizePriceBreakdown'
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  float $mode The mode in which the widget should be delivered. 1 &#x3D; separate views (compact), 2 &#x3D; all in one view (full). (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizePriceBreakdownRequest($ingredient_list, $servings, $mode = null, $default_css = null, $show_backlink = null)
    {
        // verify the required parameter 'ingredient_list' is set
        if ($ingredient_list === null || (is_array($ingredient_list) && count($ingredient_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_list when calling visualizePriceBreakdown'
            );
        }
        // verify the required parameter 'servings' is set
        if ($servings === null || (is_array($servings) && count($servings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $servings when calling visualizePriceBreakdown'
            );
        }

        $resourcePath = '/recipes/visualizePriceEstimator';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($ingredient_list !== null) {
            $formParams['ingredientList'] = ObjectSerializer::toFormValue($ingredient_list);
        }
        // form params
        if ($servings !== null) {
            $formParams['servings'] = ObjectSerializer::toFormValue($servings);
        }
        // form params
        if ($mode !== null) {
            $formParams['mode'] = ObjectSerializer::toFormValue($mode);
        }
        // form params
        if ($default_css !== null) {
            $formParams['defaultCss'] = ObjectSerializer::toFormValue($default_css);
        }
        // form params
        if ($show_backlink !== null) {
            $formParams['showBacklink'] = ObjectSerializer::toFormValue($show_backlink);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeProductNutritionByID
     *
     * Visualize Product Nutrition by ID
     *
     * @param  float $id The id of the product. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeProductNutritionByID($id, $default_css = null)
    {
        list($response) = $this->visualizeProductNutritionByIDWithHttpInfo($id, $default_css);
        return $response;
    }

    /**
     * Operation visualizeProductNutritionByIDWithHttpInfo
     *
     * Visualize Product Nutrition by ID
     *
     * @param  float $id The id of the product. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeProductNutritionByIDWithHttpInfo($id, $default_css = null)
    {
        $request = $this->visualizeProductNutritionByIDRequest($id, $default_css);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeProductNutritionByIDAsync
     *
     * Visualize Product Nutrition by ID
     *
     * @param  float $id The id of the product. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeProductNutritionByIDAsync($id, $default_css = null)
    {
        return $this->visualizeProductNutritionByIDAsyncWithHttpInfo($id, $default_css)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeProductNutritionByIDAsyncWithHttpInfo
     *
     * Visualize Product Nutrition by ID
     *
     * @param  float $id The id of the product. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeProductNutritionByIDAsyncWithHttpInfo($id, $default_css = null)
    {
        $returnType = 'string';
        $request = $this->visualizeProductNutritionByIDRequest($id, $default_css);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeProductNutritionByID'
     *
     * @param  float $id The id of the product. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeProductNutritionByIDRequest($id, $default_css = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeProductNutritionByID'
            );
        }

        $resourcePath = '/food/products/{id}/nutritionWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_css !== null) {
            $queryParams['defaultCss'] = ObjectSerializer::toQueryValue($default_css);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeEquipmentByID
     *
     * Visualize Recipe Equipment by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeEquipmentByID($id, $default_css = null)
    {
        list($response) = $this->visualizeRecipeEquipmentByIDWithHttpInfo($id, $default_css);
        return $response;
    }

    /**
     * Operation visualizeRecipeEquipmentByIDWithHttpInfo
     *
     * Visualize Recipe Equipment by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeEquipmentByIDWithHttpInfo($id, $default_css = null)
    {
        $request = $this->visualizeRecipeEquipmentByIDRequest($id, $default_css);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeEquipmentByIDAsync
     *
     * Visualize Recipe Equipment by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeEquipmentByIDAsync($id, $default_css = null)
    {
        return $this->visualizeRecipeEquipmentByIDAsyncWithHttpInfo($id, $default_css)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeEquipmentByIDAsyncWithHttpInfo
     *
     * Visualize Recipe Equipment by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeEquipmentByIDAsyncWithHttpInfo($id, $default_css = null)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeEquipmentByIDRequest($id, $default_css);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeEquipmentByID'
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeRecipeEquipmentByIDRequest($id, $default_css = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipeEquipmentByID'
            );
        }

        $resourcePath = '/recipes/{id}/equipmentWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_css !== null) {
            $queryParams['defaultCss'] = ObjectSerializer::toQueryValue($default_css);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeIngredientsByID
     *
     * Visualize Recipe Ingredients by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeIngredientsByID($id, $default_css = null)
    {
        list($response) = $this->visualizeRecipeIngredientsByIDWithHttpInfo($id, $default_css);
        return $response;
    }

    /**
     * Operation visualizeRecipeIngredientsByIDWithHttpInfo
     *
     * Visualize Recipe Ingredients by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeIngredientsByIDWithHttpInfo($id, $default_css = null)
    {
        $request = $this->visualizeRecipeIngredientsByIDRequest($id, $default_css);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeIngredientsByIDAsync
     *
     * Visualize Recipe Ingredients by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeIngredientsByIDAsync($id, $default_css = null)
    {
        return $this->visualizeRecipeIngredientsByIDAsyncWithHttpInfo($id, $default_css)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeIngredientsByIDAsyncWithHttpInfo
     *
     * Visualize Recipe Ingredients by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeIngredientsByIDAsyncWithHttpInfo($id, $default_css = null)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeIngredientsByIDRequest($id, $default_css);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeIngredientsByID'
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeRecipeIngredientsByIDRequest($id, $default_css = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipeIngredientsByID'
            );
        }

        $resourcePath = '/recipes/{id}/ingredientWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_css !== null) {
            $queryParams['defaultCss'] = ObjectSerializer::toQueryValue($default_css);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeNutrition
     *
     * Visualize Recipe Nutrition
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeNutrition($ingredient_list, $servings, $default_css = null, $show_backlink = null)
    {
        list($response) = $this->visualizeRecipeNutritionWithHttpInfo($ingredient_list, $servings, $default_css, $show_backlink);
        return $response;
    }

    /**
     * Operation visualizeRecipeNutritionWithHttpInfo
     *
     * Visualize Recipe Nutrition
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeNutritionWithHttpInfo($ingredient_list, $servings, $default_css = null, $show_backlink = null)
    {
        $request = $this->visualizeRecipeNutritionRequest($ingredient_list, $servings, $default_css, $show_backlink);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeNutritionAsync
     *
     * Visualize Recipe Nutrition
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeNutritionAsync($ingredient_list, $servings, $default_css = null, $show_backlink = null)
    {
        return $this->visualizeRecipeNutritionAsyncWithHttpInfo($ingredient_list, $servings, $default_css, $show_backlink)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeNutritionAsyncWithHttpInfo
     *
     * Visualize Recipe Nutrition
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeNutritionAsyncWithHttpInfo($ingredient_list, $servings, $default_css = null, $show_backlink = null)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeNutritionRequest($ingredient_list, $servings, $default_css, $show_backlink);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeNutrition'
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeRecipeNutritionRequest($ingredient_list, $servings, $default_css = null, $show_backlink = null)
    {
        // verify the required parameter 'ingredient_list' is set
        if ($ingredient_list === null || (is_array($ingredient_list) && count($ingredient_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_list when calling visualizeRecipeNutrition'
            );
        }
        // verify the required parameter 'servings' is set
        if ($servings === null || (is_array($servings) && count($servings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $servings when calling visualizeRecipeNutrition'
            );
        }

        $resourcePath = '/recipes/visualizeNutrition';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($ingredient_list !== null) {
            $formParams['ingredientList'] = ObjectSerializer::toFormValue($ingredient_list);
        }
        // form params
        if ($servings !== null) {
            $formParams['servings'] = ObjectSerializer::toFormValue($servings);
        }
        // form params
        if ($default_css !== null) {
            $formParams['defaultCss'] = ObjectSerializer::toFormValue($default_css);
        }
        // form params
        if ($show_backlink !== null) {
            $formParams['showBacklink'] = ObjectSerializer::toFormValue($show_backlink);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeNutritionByID
     *
     * Visualize Recipe Nutrition by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeNutritionByID($id, $default_css = null)
    {
        list($response) = $this->visualizeRecipeNutritionByIDWithHttpInfo($id, $default_css);
        return $response;
    }

    /**
     * Operation visualizeRecipeNutritionByIDWithHttpInfo
     *
     * Visualize Recipe Nutrition by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeNutritionByIDWithHttpInfo($id, $default_css = null)
    {
        $request = $this->visualizeRecipeNutritionByIDRequest($id, $default_css);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeNutritionByIDAsync
     *
     * Visualize Recipe Nutrition by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeNutritionByIDAsync($id, $default_css = null)
    {
        return $this->visualizeRecipeNutritionByIDAsyncWithHttpInfo($id, $default_css)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeNutritionByIDAsyncWithHttpInfo
     *
     * Visualize Recipe Nutrition by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeNutritionByIDAsyncWithHttpInfo($id, $default_css = null)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeNutritionByIDRequest($id, $default_css);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeNutritionByID'
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeRecipeNutritionByIDRequest($id, $default_css = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipeNutritionByID'
            );
        }

        $resourcePath = '/recipes/{id}/nutritionWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_css !== null) {
            $queryParams['defaultCss'] = ObjectSerializer::toQueryValue($default_css);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipePriceBreakdownByID
     *
     * Visualize Recipe Price Breakdown by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipePriceBreakdownByID($id, $default_css = null)
    {
        list($response) = $this->visualizeRecipePriceBreakdownByIDWithHttpInfo($id, $default_css);
        return $response;
    }

    /**
     * Operation visualizeRecipePriceBreakdownByIDWithHttpInfo
     *
     * Visualize Recipe Price Breakdown by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipePriceBreakdownByIDWithHttpInfo($id, $default_css = null)
    {
        $request = $this->visualizeRecipePriceBreakdownByIDRequest($id, $default_css);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipePriceBreakdownByIDAsync
     *
     * Visualize Recipe Price Breakdown by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipePriceBreakdownByIDAsync($id, $default_css = null)
    {
        return $this->visualizeRecipePriceBreakdownByIDAsyncWithHttpInfo($id, $default_css)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipePriceBreakdownByIDAsyncWithHttpInfo
     *
     * Visualize Recipe Price Breakdown by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipePriceBreakdownByIDAsyncWithHttpInfo($id, $default_css = null)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipePriceBreakdownByIDRequest($id, $default_css);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipePriceBreakdownByID'
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeRecipePriceBreakdownByIDRequest($id, $default_css = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipePriceBreakdownByID'
            );
        }

        $resourcePath = '/recipes/{id}/priceBreakdownWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_css !== null) {
            $queryParams['defaultCss'] = ObjectSerializer::toQueryValue($default_css);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeTaste
     *
     * Visualize Recipe Taste
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeTaste($ingredient_list)
    {
        list($response) = $this->visualizeRecipeTasteWithHttpInfo($ingredient_list);
        return $response;
    }

    /**
     * Operation visualizeRecipeTasteWithHttpInfo
     *
     * Visualize Recipe Taste
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeTasteWithHttpInfo($ingredient_list)
    {
        $request = $this->visualizeRecipeTasteRequest($ingredient_list);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeTasteAsync
     *
     * Visualize Recipe Taste
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeTasteAsync($ingredient_list)
    {
        return $this->visualizeRecipeTasteAsyncWithHttpInfo($ingredient_list)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeTasteAsyncWithHttpInfo
     *
     * Visualize Recipe Taste
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeTasteAsyncWithHttpInfo($ingredient_list)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeTasteRequest($ingredient_list);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeTaste'
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeRecipeTasteRequest($ingredient_list)
    {
        // verify the required parameter 'ingredient_list' is set
        if ($ingredient_list === null || (is_array($ingredient_list) && count($ingredient_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_list when calling visualizeRecipeTaste'
            );
        }

        $resourcePath = '/recipes/visualizeTaste';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($ingredient_list !== null) {
            $formParams['ingredientList'] = ObjectSerializer::toFormValue($ingredient_list);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeTasteByID
     *
     * Visualize Recipe Taste by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeTasteByID($id)
    {
        list($response) = $this->visualizeRecipeTasteByIDWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation visualizeRecipeTasteByIDWithHttpInfo
     *
     * Visualize Recipe Taste by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeTasteByIDWithHttpInfo($id)
    {
        $request = $this->visualizeRecipeTasteByIDRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeTasteByIDAsync
     *
     * Visualize Recipe Taste by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeTasteByIDAsync($id)
    {
        return $this->visualizeRecipeTasteByIDAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeTasteByIDAsyncWithHttpInfo
     *
     * Visualize Recipe Taste by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeTasteByIDAsyncWithHttpInfo($id)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeTasteByIDRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeTasteByID'
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeRecipeTasteByIDRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipeTasteByID'
            );
        }

        $resourcePath = '/recipes/{id}/tasteWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
